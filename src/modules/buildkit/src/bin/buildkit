#!/usr/bin/env python
# $Id$
#
# Copyright 2007 Platform Computing Inc.
#
# Licensed under GPL version 2; See LICENSE for details.

import sys
import os
import pwd
import subprocess
from kusu.core.app import KusuApp
from kusu.buildkit import *
from path import path
from kusu.util.errors import InvalidBuildProfile, FileDoesNotExistError, ToolNotFound
from kusu.util.tools import mkdtemp, cpio_copytree, checkToolDeps
from Cheetah.Template import Template


class BuildKit:
    """This class is the model for the buildkit app."""
    
    verbose = False
    
    def newKitSrc(self, srcpath):
        """prepare the Kit source directory"""
        newkit = KitSrcFactory(srcpath)
        newkit.prepareSrcPath()
        
        # also create a sample build.kit
        defaultname = srcpath.basename()
        s = self.prepareBuildKitTemplate(defaultname)
        f = open('%s/build.kit' % srcpath,'w')
        f.write(s)
        f.close()
        
        
    def getKitSrc(self, srcpath):
        """ Builds the kit based on the kitsrc dir"""
        return KitSrcFactory(srcpath)

    def getKitScript(self, kitsrc, kitscript='build.kit'):
        """ Sweeps the kitsrc dir and attempts to locate the kitscript.
        """
        _kitsrc = path(kitsrc)
        li = _kitsrc.files(kitscript)
        if not li: raise FileDoesNotExistError
        
        # TODO : only handle single kitscript
        return li[0]

    def getBuildProfile(self, kitsrc):
        """ Returns the buildprofile based on kitsrc. """
        return setupprofile(kitsrc)
        
    def loadKitScript(self, kitscript):
        """ Loads the kitscript and get a tuple of the kit, components and packages defined in
            that kitscript.
        """
        ns = {}
        execfile(kitscript,globals(),ns)
        
        pkgs = [ns[key] for key in ns.keys() if isinstance(ns[key], PackageProfile)]
        comps = [ns[key] for key in ns.keys() if isinstance(ns[key], KusuComponent)]
        kits = [ns[key] for key in ns.keys() if isinstance(ns[key], KusuKit)]
        
        # FIXME: only a single kit is supported right now
        if not kits:
            kit = []
        else:
            kit = kits[0]
        
        return (kit,comps,pkgs)
        
    def handlePackages(self, packages, buildprofile):
        """ Handles the configuring, building and deploying of the packages. """
        for p in packages:
            p.verbose = self.verbose
            p.buildprofile = buildprofile
            p.setup()
            p.configure()
            p.build()
            p.deploy()
            
    def handleComponents(self, components, buildprofile):
        """ Handles the configuring, building and deploying of the components. """
        for c in components:
            c.buildprofile = buildprofile
            c.deploy(verbose=self.verbose)
            
    def handleKit(self, kit, buildprofile):
        """ Handles the configuring, building and deploying of the kit. """
        kit.buildprofile = buildprofile
        kit.deploy(verbose=self.verbose)
        
    def populatePackagesDir(self, buildprofile):
        """ Populates the built or binary packages into the package directory. """
        populatePackagesDir(buildprofile)
        
    def setupRPMMacros(self, buildprofile):
        """ Sets up a proper .rpmmacros file for building purposes. """
        curRPMMacros = setupRPMMacrofile(buildprofile)
        
    def restoreRPMMacros(self, oldrpmmacros):
        """ Restores the old .rpmmacros. """
        userhome = path(pwd.getpwuid(os.getuid())[5])
        rpmmacros = userhome / '.rpmmacros'
        if rpmmacros.exists():
            rpmmacros.remove()
        cmd = 'mv -f %s %s' % (currpmmacro,rpmmacros)
        renP = subprocess.Popen(cmd,shell=True)
        renP.wait()
        
    def generateKitInfo(self, kit, filepath):
        """ Generates the kitinfo which contains the metadata information 
            regarding the kit and its components.
        """
        kit.generateKitInfo(filepath)
        
    def prepareBuildKitTemplate(self, defaultname):
        """ Gets the build.kit template and populate it with the correct 
            namespace. The defaultname is just a string to set the default
            component and kit names.
        """
        tmpl = getBuildKitTemplate()
        ns = {}

        # get this system's distro and version
        dist = os.environ.get('KUSU_DIST','')
        distver = os.environ.get('KUSU_DISTVER','')
        if dist == 'fedora' and distver == '6':
            compclass = 'Fedora6Component()'
        elif dist == 'centos' and distver == '5':
            compclass = 'Centos5Component()'
        elif dist == 'rhel' and distver == '5':
            compclass == 'RHEL5Component()'
        else:
            compclass = 'DefaultComponent()'

        ns['compclass'] = compclass
        ns['compname'] = defaultname
        ns['kitclass'] = 'DefaultKit()'
        ns['kitname'] = defaultname
        t = Template(file=str(tmpl),searchList=[ns])
        return str(t)
        
        
    def makeKitISO(self, kitsrc):
        """ Creates a Kusu Kit ISO based on the kitsrc dir.
            Returns the isofile.
        """
        kitsrc = path(kitsrc).abspath()
        pkgdir = path(kitsrc / 'packages')

        # sweep and get the kitinfo files    
        li = kitsrc.files('kitinfo')
        kitinfo = path(li[0])

        kit,comps = processKitInfo(kitinfo)

        if not kit: return


        # TODO : right now, we don't make use of the kitversion, only kitnames
        # TODO : also, only a single kit is supported right now

        tmpdir = kitsrc / 'tmp'
        isodir = mkdtemp(dir=tmpdir,prefix='isodir-')
        kitdir = path(isodir / kit['name'])
        kitdir.mkdir()
        cpio_copytree(pkgdir,kitdir)
        kitinfo.copy(kitdir)
        isofile = 'kit-%(name)s-%(version)s-%(release)s-%(arch)s.iso' % kit
        cmd = 'mkisofs -quiet -V "%s" -r -T -f -o %s/%s .' % (kit['name'],kitsrc,isofile)
        mkP = subprocess.Popen(cmd,shell=True,cwd=isodir)
        mkP.wait()
        isodir.rmtree()
        isopath = kitsrc / isofile
        return isopath
        
        
class App(KusuApp):
    """ Application class for buildkit. """

    def __init__(self, bminst):
        """ App-specific initialization. """
        KusuApp.__init__(self)

        self.actions = {'new':['kit'], 
            'make':['kit']}

        # self.action and self.actionargs will hold the current action and its arguments            
        self.action = None 
        self.actionargs = None

        # an instance of the BuildKit for managing the actions        
        self.bkinst = bkinst
        self.usagestr = self._("""\
buildkit [-h|-v] <action> arg1=val1 arg2=val2 ...

buildkit is used to construct new Kusu Kits.

actions:

    new             - Create a new Kit directory. Available arguments for 
                      this action:
                        kit=<name of kit directory to create>
    make            - Make a Kit iso. Available arguments for this action:
                        kit=<path of kit directory>
                 
""")
        self.examples = self._("""\
Example operations:

    To prepare a new Kit called hellokit:
    # buildkit new kit=hellokit

    To make the hello Kit:
    # buildkit make kit=hellokit

""")
        self.parser.set_usage(self.usagestr)

    def printUsageExit(self):
        """ Print usage text and exit. """
        self.stdoutMessage(self.usagestr)
        sys.stdout.write(os.linesep)
        sys.exit(0)

    def printExamplesExit(self):
        """ Print examples text and exit. """
        self.stdoutMessage(self.examples)
        sys.exit(0)

    def printMsgExit(self, msg, exitcode=1):
        """ Print msg and exit. """
        self.stdoutMessage(msg)
        sys.stdout.write(os.linesep)
        sys.exit(exitcode)

    def handleArgPairs(self, arglist):
        """ Handle the argument list and return a dict of key-value pairs. """

        li = []
        d = {}

        for s in arglist:
            li2 = s.split('=')
            for s2 in li2: 
                if s2: li.append(s2)        

        # There should be even number of items in order to make pairs
        if not len(li) % 2: 
            # Collect the pairs
            while li:
                d[li[0].lower()] = li[1]
                del li[0:2]

        return d

    def parseargs(self):
        """ App-specific arguments goes here. """

        self.parser.add_option('-v','--verbose', action='store_true', dest='verbose')
        self.parser.add_option('-s','--kitscript', action='store', dest='kitscript')
        self.parser.add_option('-H','--examples', action='store_true', dest='showexamples')
        self.parser.set_defaults(verbose=False,showexamples=False,kitscript='build.kit')
        self.options, self.args = self.parser.parse_args()


        if self.options.showexamples:
            self.printExamplesExit()

        if len(self.args) < 2:
            self.printUsageExit()


        # check if the first parsed argument is a supported action
        action = self.args[0]


        if action not in self.actions.keys():
            self.printUsageExit()
        d = self.handleArgPairs(self.args[1:])

        if not d:
            self.printUsageExit()

        # iterate keys in d and validate against the commands'
        # list of keys
        for k in d.keys():
            if k not in self.actions[action]:
                self.printUsageExit()

        self.action = action
        self.actionargs = d

    def run(self):
        """ Main launcher. """
        self.parseargs()

        # set verbosity
        self.bkinst.verbose = self.options.verbose

        # call the correct sub-handler for the action
        m = '_' + self.action.split('-')[0] \
            + ''.join([l.capitalize() for l in self.action.split('-')[1:]])

        handler = getattr(self,m)

        handler(self.actionargs)
    
    def _new(self, args):
        """ Handler for new action. args is a dict of supported key-value pairs for this action. """
        dirname = path(args['kit'])
        
        if dirname.exists():
            msg = self._('There is already a directory called %(dirname)s. Please remove it and try again.' % {'dirname':dirname})
            self.printMsgExit(msg)          

        msg = self._('Creating %(kitname)s directory..' % {'kitname':dirname.basename()})
        print msg
        self.bkinst.newKitSrc(dirname)
        msg = self._('%(kitname)s directory created.' % {'kitname':dirname.basename()})
        print msg

    def _make(self, args):
        """ Handler for make action. args is a dict of supported key-value pairs for this action. """
        kitsrc = path(args['kit']).abspath()
        oldrpmmacros = ''
        
        # first check if mkisofs is installed
        try:
            checkToolDeps('mkisofs')
        except ToolNotFound:
            msg = self._('Unable to locate mkisofs! Please ensure that it is available.')
            self.printMsgExit(msg)
            
        # get the kitsrc
        msg = self._('Verifying the Kit Source directory found in %(kitsrc)s..' % {'kitsrc':kitsrc})
        print msg
        _kitsrc = self.bkinst.getKitSrc(kitsrc)
        
        if not _kitsrc.verifySrcPath():
            msg = self._('Unable to use %(kitsrc)s as a Kit Source directory!' % {'kitsrc':kitsrc})
            self.printMsgExit(msg)
            
        bp = None
        try:
            msg = self._('Setting up BuildProfile for this kit..')
            print msg
            bp = self.bkinst.getBuildProfile(kitsrc)
        except InvalidBuildProfile:
            msg = self._('Unable to create a BuildProfile based on this Kit Source directory!')
            self.printMsgExit(msg)
            
        if not bp.builddir or not bp.pkgdir or not bp.srcdir or not bp.tmpdir:
            msg = self._('Unable to create a BuildProfile based on this Kit Source directory!')
            self.printMsgExit(msg)

        # set up the .rpmmacros
        msg = self._('Setting up a proper .rpmmacros for building this kit')
        print msg
        oldrpmmacros = self.bkinst.setupRPMMacros(bp)


        # get the kitscript
        _ks = self.options.kitscript
        kitscript = ''
        try:
            msg = self._('Looking for the kitscript %(kitscript)s..' % {'kitscript':_ks})
            print msg
            kitscript = self.bkinst.getKitScript(kitsrc,_ks)
        except FileDoesNotExistError:
            if oldrpmmacros:
                msg = self._('Restoring .rpmmacros')
                self.bkinst.restoreRPMMacros(oldrpmmacros)
            msg = self._('kitscript %(kitscript)s not found!' % {'kitscript':_ks})
            self.printMsgExit(msg)
            
        # looks like everything is down pat, now the hard stuff
        msg = self._('Found kitscript. Loading it..')
        print msg
        kit, components, packages = self.bkinst.loadKitScript(kitscript)
        
        # lets build the packages if any:
        if packages:
            msg = self._('Building the package(s)..')
            print msg
            self.bkinst.handlePackages(packages,bp)
            
        if components:
            msg = self._('Building the packages for component(s)..')
            self.bkinst.handleComponents(components,bp)
            print msg
            
        if kit:
            msg = self._('Building the package for the kit..')
            self.bkinst.handleKit(kit,bp)
            print msg
            
        # populate the packages dir
        msg = self._('Populating the packages directory with the Kit artifacts..')
        print msg
        self.bkinst.populatePackagesDir(bp)
        
        # generate the kitinfo file
        msg = self._('Generating kitinfo..')
        print msg
        kitinfo = '%s/kitinfo' % kitsrc
        self.bkinst.generateKitInfo(kit,kitinfo)
        
        # finally, make the kit iso
        msg = self._('Creating the Kit iso..')
        print msg
        kitiso = self.bkinst.makeKitISO(kitsrc)
        
        if not kitiso:
            msg = self._('Error creating Kit ISO!')
            if oldrpmmacros:
                msg = self._('Restoring .rpmmacros')
                self.bkinst.restoreRPMMacros(oldrpmmacros)
            self.printMsgExit(msg)
                
        msg = self._('Kit ISO created. ISO file is at %(isofile)s.' % {'isofile':kitiso})
        print msg
        
        if oldrpmmacros:
            msg = self._('Restoring .rpmmacros')
            self.bkinst.restoreRPMMacros(oldrpmmacros)
        
        
if __name__ == '__main__':
	bkinst = BuildKit()
	app = App(bkinst)
	app.run()
	sys.exit(0)

