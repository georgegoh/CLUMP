#!/usr/bin/env python
# $Id$
#
# Copyright 2007 Platform Computing Corporation.
#
# Licensed under GPL version 2; See LICENSE for details.
#

import sys
import os
from kusu.core.app import KusuApp
from path import path
from kusu.boot.distro import CopyError
from kusu.boot.distro import FileAlreadyExists
from kusu.boot.tool import BootMediaTool

        
        
class BootMediaApp(KusuApp):
    """ Application class for boot-media-tool. """
    
    def __init__(self, bminst):
        """ App-specific initialization. """
        KusuApp.__init__(self)
        
        self.actions = {'query':['source'], 
            'extract':['source','image','dest'], 
            'unpack':['initrd','dir'], 
            'pack':['dir','initramfs','template'], 
            'make-isolinux':['dir','os',
                    'kernel','initrd',
                    'isobin'],
            'make-iso':['dir','iso','source'],
            'make-boot-tgz':['dir','bootarchive'],
            'make-patch':['dir']}
        
        # self.action and self.actionargs will hold the current action and its arguments            
        self.action = None 
        self.actionargs = None
        
        # an instance of the BootMediaTool for managing the actions        
        self.bminst = bminst
        self.usagestr = self._("""\
boot-media-tool [-h|-v] <action> arg1=val1 arg2=val2 ...

boot-media-tool builds Kusu Boot Media from supported Linux distros' 
installation sources. The tool also queries and extracts kernel/initrd 
images from these sources.

Options:

    -h          - Provide the tool help (this screen).
    -v          - Provide the version string.
    -H          - Provide usage examples.
    -f          - Force overwriting when extracting kernel/initrd.

Actions:

    query           - Probes and displays any kernel/initrd in the 
                      installation source. Available arguments for 
                      this action: 
                        source=<path of installation source>
    extract         - Extracts the kernel/initrd from the installation 
                      source. Available arguments for this action:
                        source=<path of installation source>
                        image=<kernel|initrd|all>
    unpack          - Unpacks the specified initrd into a directory. 
                      Available arguments for this action:
                        initrd=<path of initrd file>
                        dir=<directory to unpack into>    
    pack            - Packs the rootfs directory into a initramfs image.
                      An optional init script template can be passed. 
                      Available arguments for this action:
                        dir=<path of rootfs directory>
                        initramfs=<name of initramfs file>
                        template=<init script template file>
    make-isolinux   - Make isolinux directory with the specified kernel 
                      and initrd. Available arguments for this action:
                        dir=<directory for isolinux>
                        os=<the os for the kernel/initrd>
                        kernel=<path of kernel file>
                        initrd=<path of initrd file>
                        isobin=<path of isolinux.bin>
    make-iso        - Make the Kusu Boot Media iso from the isolinuxdir.
                      Available arguments for this action:
                        patch=<path of installer patch>
                        iso=<name of iso file>
                        source=<path of installation source>
    make-boot-tgz   - Make the Kusu BootArchive from the isolinuxdir which
                      then can be included in a Kusu Kit to make it bootable. 
                      Available arguments for this action:
                        bootarchive=<name of bootarchive>
                        dir=<path of isolinuxdir>
    make-patch      - Make the installer patchfile based on OS. Available
                      arguments for this action:
                        dir=<directory containing Kusu Installer runtime>
""")
        self.examples = self._("""\
Example operation usages:

    To query installation source mounted at /media/cdrom:
    # boot-media-tool query source=/media/cdrom

    To extract the kernel from the installation source:
    # boot-media-tool extract source=/media/cdrom image=kernel

    To extract the initrd from the installation source:
    # boot-media-tool extract source=/media/cdrom image=initrd

    To unpack the initrd into a directory called foodir:
    # boot-media-tool unpack initrd=initrd.img dir=foodir

    To pack the rootfs directory called foodir into an initramfs image:
    # boot-media-tool pack dir=foodir initramfs=initram.img

""")
        self.parser.set_usage(self.usagestr)
        
    def printUsageExit(self):
        """ Print usage text and exit. """
        self.stdoutMessage(self.usagestr)
        sys.exit(0)
        
    def printExamplesExit(self):
        """ Print examples text and exit. """
        self.stdoutMessage(self.examples)
        sys.exit(0)
        
    def printMsgExit(self, msg):
        """ Print msg and exit. """
        self.stdoutMessage(msg)
        sys.stdout.write(os.linesep)
        sys.exit(1)
        
        
    def handleArgPairs(self, arglist):
        """ Handle the argument list and return a dict of key-value pairs. """
        
        li = []
        d = {}
        
        for s in arglist:
            li2 = s.split('=')
            for s2 in li2: 
                if s2: li.append(s2)        

        # There should be even number of items in order to make pairs
        if not len(li) % 2: 
            # Collect the pairs
            while li:
                d[li[0].lower()] = li[1]
                del li[0:2]
        
        return d

    def parseargs(self):
        """ App-specific arguments goes here. """
        
        self.parser.add_option('-f','--force', action='store_true', dest='overwrite')
        self.parser.add_option('-H','--examples', action='store_true', dest='showexamples')
        self.options, self.args = self.parser.parse_args()
        

        if self.options.showexamples:
            self.printExamplesExit()
        
        if len(self.args) < 2:
            self.printUsageExit()
            
        # check if the first parsed argument is a supported action
        action = self.args[0]
        
        
        if action not in self.actions.keys():
            self.printUsageExit()
        d = self.handleArgPairs(self.args[1:])
        
        if not d:
            self.printUsageExit()
            
        # iterate keys in d and validate against the commands'
        # list of keys
        for k in d.keys():
            if k not in self.actions[action]:
                self.printUsageExit()
                
        self.action = action
        self.actionargs = d
        
    def run(self):
        """ Main launcher. """
        self.parseargs()
        
        # call the correct sub-handler for the action
        m = '_' + self.action.split('-')[0] \
            + ''.join([l.capitalize() for l in self.action.split('-')[1:]])
            
        handler = getattr(self,m)
        
        handler(self.actionargs)
        

    def _query(self,args):
        """Handler for query action. args is a dict of supported key-value pairs for this action. """
        srcpath = path(args['source'])
        if not self.bminst.validSrcPath(srcpath):
            msg = self._('invalidSrcPath')
            self.printMsgExit(msg)
            
        distro = self.bminst.getDistro(srcpath)
        kernpath = self.bminst.getKernelPath(srcpath)
        initrdpath = self.bminst.getInitrdPath(srcpath)
        
        if distro:
            print self._('OS Type:'), distro
        else:
            print self._('Cannot determine OS type.')
            
        if kernpath:
            print self._('Kernel found:'), kernpath
        else:
            print self._('Cannot find kernel.')

        if initrdpath:
            print self._('Initrd found:'), initrdpath
        else:
            print self._('Cannot find initrd.')
        
    def _pack(self,args):
        """Handler for pack action. args is a dict of supported key-value pairs for this action. """
        dirname = path(args['dir'])
        initramfs = path(args['initramfs'])
        template = args.get('template',None)

        try:
            self.bminst.packRootImg(dirname,initramfs,template)
            print self._('Packed %(dirname)s into %(initramfs)s') % {'dirname':dirname, 'initramfs':initramfs}
        except NotPriviledgedUser:
            msg = self._('This operation requires root access.')
            self.printMsgExit(msg)
        except FilePathError:
            msg = self._('File path error. Please ensure the paths are valid.')
            self.printMsgExit(msg)        

    def _unpack(self,args):
        """Handler for unpack action. args is a dict of supported key-value pairs for this action. """
        initrd = path(args['initrd'])
        dirname = args['dir']
        
        try:
            self.bminst.unpackRootImg(initrd,dirname)
            print self._('Unpacking initrd to'), dirname
        except NotPriviledgedUser:
            msg = self._('This operation requires root access.')
            self.printMsgExit(msg)
        except FilePathError:
            msg = self._('Path of initrd file not found. Please ensure path is valid.')
            self.printMsgExit(msg)

    def _extract(self,args):
        """Handler for extract action. args is a dict of supported key-value pairs for this action. """
        imagetype = args['image'].lower()
        srcpath = path(args['source'])
        dest = args.get('dest',None)
        overwrite = self.options.overwrite
        
        if not dest: 
            dest = path.getcwd()
        else:
            dest = path(dest)
        try:
            if imagetype == 'kernel':
                if not self.bminst.copyKernel(srcpath, dest, overwrite):
                    msg = self._('Error extracting kernel.')
                    self.printMsgExit(msg)
                else:
                    print self._('Extracting kernel to'), dest
            elif imagetype == 'initrd':
                if not self.bminst.copyInitrd(srcpath, dest, overwrite):
                    msg = self._('Error extracting initrd.')
                    self.printMsgExit(msg)
                else:
                    print self._('Extracting initrd to'), dest            
            elif imagetype == 'all':  
                if not self.bminst.copyKernel(srcpath, dest, overwrite):
                        msg = self._('Error extracting kernel.')
                        self.printMsgExit(msg)
                else:
                    print self._('Extracting kernel to'), dest
                if not self.bminst.copyInitrd(srcpath, dest, overwrite):
                        msg = self._('Error extracting initrd.')
                        self.printMsgExit(msg)
                else:
                    print self._('Extracting kernel to'), dest
        except FileAlreadyExists, e:
            if imagetype != 'all' and not overwrite:
                msg = self._('The %(imagetype)s file already exists in %(dest)s. Use -f to force overwriting the file') \
                        % {'imagetype':imagetype, 'dest':dest}
                self.printMsgExit(msg)
            elif imagetype == 'all' and not overwrite:
                msg = self._('The kernel/initrd files already exist in %(dest)s.\nUse -f to force overwriting the files') \
                        % {'dest':dest}
                self.printMsgExit(msg)
            
        
    def _makeIso(self,args):
        """Handler for make-iso. args is a dict of supported key-value pairs for this action. """
        dirname = path(args['dir'])
        iso = path(args['iso'])
        srcpath = path(args['source'])
                  
        try:
            self.bminst.mkBootISO(dirname, iso, volname="BootKit")
            print self._('Generated %(iso)s from %(dirname)s') % {'dirname':dirname, 'iso':iso}
        except FilePathError:
            msg = self._('File path error. Please ensure the directory path is valid.')
            self.printMsgExit(msg)        

    def _makeIsolinux(self,args):
        """Handler for make-isolinux. args is a dict of supported key-value pairs for this action. """
        dirname = path(args['dir'])
        ostype = args['os']
        kernpath = path(args['kernel'])
        initrdpath = path(args['initrd'])
        isobin = path(args['isobin'])

        try:
            self.bminst.mkISOLinuxDir(dirname, kernpath, initrdpath, ostype, isobin)
            print self._('Updated isolinux.cfg in %(dirname)s') % {'dirname':dirname}
        except FilePathError:
            msg = self._('File path error. Please ensure the paths are valid.')
            self.printMsgExit(msg)

    def _makeBootTgz(self,args):
        """Handler for make-boot-tgz. args is a dict of supported key-value pairs for this action. """
        dirname = path(args['dir'])
        bootarchive = path(args['bootarchive'])
      
        try:
            self.bminst.mkBootArchive(dirname, bootarchive)
            print self._('Created BootArchive %(bootarchive)s from %(dirname)s') \
                % {'dirname':dirname,'bootarchive':bootarchive}
        except FilePathError:
            msg = self._('File path error. Please ensure the directory is valid.')
            self.printMsgExit(msg)
            
    def _makePatch(self, args):
        """Handler for make-patch. args is a dict of supported key-value pairs for this action. """
        dirname = path(args['dir'])
   
if __name__ == '__main__':
    bminst = BootMediaTool()
    app = BootMediaApp(bminst)
    app.run()


