#!/usr/bin/env python
# $Id$
#
# Copyright 2007 Platform Computing Inc.
#
# Licensed under GPL version 2; See LICENSE for details.

import sys
import os
from path import path
from kusu.core.app import KusuApp
from kusu.core import database as db
from kusu.util import tools as utiltools
from kusu.util import rpmtool
from kusu.repoman import tools as repotools
from kusu.driverpatch import DriverPatchController
from kusu.util.errors import InvalidPathError, FileDoesNotExistError, InvalidArguments, \
                            UnknownKernelModuleAsset, DirDoesNotExistError, UnknownFileTypeError, \
                            RepoNotFoundError

import kusu.util.log as kusulog
kl = kusulog.getKusuLog()
kl.addFileHandler(path(os.environ.get('KUSU_TMP', '/tmp/kusu')) /
                       'kusu-driverpatch.log')
kl = kusulog.getKusuLog('driverpatch-app')

SUPPORTED_KERNEL_ARCHES = ['i586','i686','x86_64']

def printTable(titles, entries, widths):
    horline = '+'
    for width in widths:
        horline += '-' * (width + 2) + '+'

    print horline

    line = '|'
    for x in xrange(len(titles)):
        line += ' ' + titles[x].ljust(widths[x]) + ' |'

    print line
    print horline

    for entry in entries:
        newlines = True
        while newlines:
            newlines = False

            line = '|'
            for x in xrange(len(entry)):
                newline = entry[x].find('\n')
                if newline == -1:
                    thisentry = entry[x]
                    nextentry = ''
                else:
                    newlines = True
                    thisentry = entry[x][:newline]
                    nextentry = entry[x][newline + 1:]

                line += ' ' + thisentry.ljust(widths[x]) + ' |'
                entry[x] = nextentry

            print line

    print horline

        
class App(KusuApp):
    """ Application class for buildkit. """

    def __init__(self):
        """ App-specific initialization. """
        KusuApp.__init__(self)

        self.actions = {'nodegroup':['name','id','arch','version',
                        'kernel','initrd','assetsdir'], 
            'list':['name','id']}

        # self.action and self.actionargs will hold the current action and its arguments            
        self.action = None 
        self.actionargs = None
        

        self.usagestr = self._("""\
driverpatch [-h|-v] <action> arg1=val1 arg2=val2 ...

driverpatch is used to update initrd images related to package-based
deployments.


actions:

    nodegroup       - Updates the PXE kernel/initrd with the driverpacks
                      belonging to the specified nodegroup. Nodegroup
                      can be specified with name OR id:

                      REQUIRED ARGS:
                        name=<nodegroup name> | id=<nodegroup id>
                        
                      OPTIONAL ARGS:
                        arch=<arch of the kernel/initrd>
                        version=<specific kernel version to use>
                        kernel=<filepath of resulting kernel>
                        initrd=<filepath of resulting initrd>
                        assetsdir=<dir containing modules assets>
    
    list            - List the driverpacks that is associated to
                      the specified nodegroup. Nodegroup can be
                      specified with name OR id:

                      REQUIRED ARGS:
                        name=<nodegroup name> | id=<nodegroup id>

""")
        self.examples = self._("""\
Example operations:

    To patch initrds belonging to a nodegroup named compute
    # driverpatch nodegroup name=compute
    
    To patch initrds for i686 belonging to a nodegroup id of 3
    # driverpatch nodegroup id=3 arch=i686
    
    To list driverpacks that is associated to a nodegroup 
    named compute:
    # driverpatch list name=compute

    To list driverpacks that is associated to a nodegroup 
    id of 3:
    # driverpatch list id=3

""")
        self.parser.set_usage(self.usagestr)

    def printUsageExit(self):
        """ Print usage text and exit. """
        self.stdoutMessage(self.usagestr)
        sys.stdout.write(os.linesep)
        sys.exit(0)

    def printExamplesExit(self):
        """ Print examples text and exit. """
        self.stdoutMessage(self.examples)
        sys.exit(0)

    def printMsgExit(self, msg, exitcode=1):
        """ Print msg and exit. """
        self.stdoutMessage(msg)
        sys.stdout.write(os.linesep)
        sys.exit(exitcode)

    def handleArgPairs(self, arglist):
        """ Handle the argument list and return a dict of key-value pairs. """

        li = []
        d = {}

        for s in arglist:
            li2 = s.split('=')
            for s2 in li2: 
                if s2: li.append(s2)        

        # There should be even number of items in order to make pairs
        if not len(li) % 2: 
            # Collect the pairs
            while li:
                d[li[0].lower()] = li[1]
                del li[0:2]

        return d


    def parseargs(self):
        """ App-specific arguments goes here. """

        self.parser.add_option('-v','--verbose', action='store_true', dest='verbose')
        self.parser.add_option('-H','--examples', action='store_true', dest='showexamples')
        self.parser.add_option('-u','--update', action='store_true', dest='update',
                                help=self._('Update the kernel/initrd entries in database.'))
        self.parser.add_option('--dbdriver', dest='dbdriver',
                                help=self._('Database driver (sqlite, mysql)'))
        self.parser.add_option('--dbdatabase', dest='dbdatabase',
                                help=self._('Database'))
        self.parser.add_option('--dbuser', dest='dbuser',
                                help=self._('Database username'))
        self.parser.add_option('--dbpassword', dest='dbpassword',
                                help=self._('Database password'))
        self.parser.set_defaults(verbose=False,showexamples=False,update=False)
        self.options, self.args = self.parser.parse_args()


        if self.options.showexamples:
            self.printExamplesExit()

        if len(self.args) < 2:
            self.printUsageExit()


        # check if the first parsed argument is a supported action
        action = self.args[0]


        if action not in self.actions.keys():
            self.printUsageExit()
        d = self.handleArgPairs(self.args[1:])

        if not d:
            self.printUsageExit()

        # iterate keys in d and validate against the commands'
        # list of keys
        for k in d.keys():
            if k not in self.actions[action]:
                self.printUsageExit()

        self.action = action
        self.actionargs = d

    def run(self):
        """ Main launcher. """
        self.parseargs()

        # get the db instance
        dbdriver = 'mysql'
        dbdatabase = 'kusudb'
        dbuser = 'apache'
        dbpassword = None
        if self.options.dbdriver:
            dbdriver = self.options.dbdriver
        if self.options.dbdatabase:
            dbdatabase = self.options.dbdatabase
        if self.options.dbuser:
            dbuser = self.options.dbuser
        if self.options.dbpassword:
            dbpassword = self.options.dbpassword


        self.db = db.DB(dbdriver, dbdatabase, dbuser, dbpassword)

        # an instance of the controller for managing the actions        
        self.controller = DriverPatchController(self.db)

        # set verbosity
        self.verbose = self.options.verbose

        # call the correct sub-handler for the action
        m = '_' + self.action.split('-')[0] \
            + ''.join([l.capitalize() for l in self.action.split('-')[1:]])

        handler = getattr(self,m)

        handler(self.actionargs)
    
    def _nodegroup(self, args):
        """ Handler for nodegroup action. args is a dict of supported key-value pairs for this action. """
        ngname = args.get('name','')
        ngid = args.get('id','')
        karch = args.get('arch','')
        kver = args.get('version','')
        kernelfile = args.get('kernel','')
        initrdfile = args.get('initrd','')
        assetsdir = args.get('assetsdir','')
        
        if not ngid and not ngname:
            self.printUsageExit()
            
        #if not karch:
        #    self.printUsageExit()
            
        #if not karch in SUPPORTED_KERNEL_ARCHES:
        #    msg = self._('Arch %(karch)s not supported!' %
        #                {'karch':karch})
        #    self.printMsgExit(msg)
        
        if ngname:
            ngkey = 'name'
        elif ngid:
            ngkey = 'id'
            
        # get the ngname
        if ngkey == 'id':
            try:
                _ngid = long(ngid)
            except ValueError:
                msg = self._('id should be a number!')
                self.printMsgExit(msg)
            
            _ng = self.db.NodeGroups.select_by(ngid=_ngid)
            if _ng:
                ng = _ng[0]
                ngname = ng.ngname
            else:
                msg = self._('Nodegroup not found!')
                self.printMsgExit(msg)
    
        else:
            # validate the supplied ngname
            _ng = self.db.NodeGroups.select_by(ngname=ngname)
            if not _ng:
                msg = self._('Nodegroup not found!')
                self.printMsgExit(msg)

            
        # get the available driverpacks
        try:
            dpacks = self.controller.getDriverPacks(id=ngid,name=ngname)
        except ValueError:
            msg = self._('id should be a number!')
            self.printMsgExit(msg)
            
        if not dpacks:
            msg = self._("No valid driverpacks found. Please ensure that the nodegroup's installtype is package-based.")
            self.printMsgExit(msg)
                    
        # get the correct dpacks
        #dprpms = [dpack.dpname for dpack in dpacks if dpack.dpname.find(karch) >-1]
        dprpms = [dpack.dpname for dpack in dpacks]

        if not dprpms:
            msg = self._('No valid driverpacks found.')
            self.printMsgExit(msg)            
        
        for dprpm in dprpms:
            msg = self._('Found valid driverpack: %(dpname)s' %
                        {'dpname':dprpm})
            print msg
            
        # get the repoid for this nodegroup
        if not repotools.repoForNodeGroupExists(self.db,ngname):
            msg = self._('No valid repo available this nodegroup!')
            self.printMsgExit(msg)
            
        repoid = repotools.getRepoFromNodeGroup(self.db,ngname)
        repos = self.db.Repos.select_by(repoid=repoid)
        repo = repos[0].repository
        if not repo:
            msg = self._('No valid repo available for this nodegroup!')
            self.printMsgExit(msg)
            
        msg = self._('Looking in %(repository)s..' %
                    {'repository':repo})
        print msg
        
        # lets get the driverpacks packages
        pkglist = []
        for dprpm in dprpms:
            try:
                pkg = repotools.getPackageFilePath(self.db,repoid,dprpm)
                pkglist.append(pkg)
            except RepoNotFoundError:
                msg = self._('No valid repo available for this nodegroup!')
                self.printMsgExit(msg)
            except FileDoesNotExistError:
                msg = self._('%(pkgname)s not available in for the repo belong to this nodegroup! Skipping.' %
                            {'pkgname':dprpm})
                print msg
 
        for pkg in pkglist:
            msg = self._('Found %(pkgname)s..' %
                        {'pkgname':pkg})
            print msg
        
        tftpbootdir = path('/tftpboot/kusu')
        if not tftpbootdir.exists():
            msg = self._('/tftpboot/kusu not found! Aborting operation.')
            self.printMsgExit(msg)
        
        # get the kernel rpm
        li = []
        for pkg in pkglist:
            if self.controller.isKernelPackage(pkg):
                li.append(pkg)

        if not li:
            msg = self._('Kernel rpm not found!')
            self.printMsgExit(msg)
            
        # remove the kernel rpms for the pkglist
        kmodlist = [rpmtool.RPM(str(pkg)) for pkg in pkglist if not pkg in li]
        
        # if there are more than one kernel rpms, get the highest one

        if len(li) > 1:
            krpms = [rpmtool.RPM(str(l)) for l in li]
            try:
                krpms.sort()
            except RPMComparisonError:
                msg = self._('Different types of kernel packages found for this distro! This is unsupported!')
                self.printMsgExit(msg)
                
            kernelrpm = krpms[-1]   # last one is the highest
        else:
            kernelrpm = rpmtool.RPM(str(li[0]))

        msg = self._('Using %(package)s as the kernel package.' %
                {'package':str(kernelrpm)})
                
        # add the select kernelrpm into the kernel modules list
        kmodlist.insert(0,kernelrpm)
        
        # get the current kernel/initrd for this nodegroup
        _ng = self.db.NodeGroups.select_by(ngname=ngname)

        # FIXME: Ensure the ngedit has not updated the kernel/initrd fields!
        ngkernel = _ng[0].kernel
        nginitrd = _ng[0].initrd

        tmpdir = path(utiltools.mkdtemp())

        # get the existing initrd
        initrdpath = tftpbootdir / nginitrd
        if not initrdpath.exists():
            msg = self._('Current initrd %(initrdpath)s not found! Aborting operation!' %
                        {'initrdpath':initrdpath})
            self.printMsgExit(msg)
            
        self.controller.unpackInitrdImage(initrdpath,tmpdir)
        # get the modules cgz
        oldmodulescgz = self.controller.getKernelModulesCgz(tmpdir)
        oldmodulescgz.remove()
        
        # get the other modules assets
        moduleassets = self.controller.getKernelModulesAssets(tmpdir)
        
        tmpkmoddir = path(utiltools.mkdtemp())
        tmppcidir = path(utiltools.mkdtemp())
        
        # extract kernel modules from the driverpacks table
        for pkg in kmodlist:
            msg = self._('Extracting kernel modules from package %(packagerpm)s..' %
                    {'packagerpm':pkg.filename})
            print msg
            # check if the package has a pci.updates
            # FIXME: currently only handling pci.updates! we are missing the support for pcitable types of updates.
            if self.controller.hasPciUpdates(pkg.filename): 
                self.controller.extractPciUpdates(pkg.filename,tmppcidir)
                pciupdates = path(tmppcidir / 'pci.updates')
                if not pciupdates.exists():
                    msg = self._('Error extracting pci.updates from %(packagerpm)s' %
                                {'packagerpm':pkg.filename})
                    self.printMsgExit(msg)
                # get system pci.ids found in the initrd and patch it with the new pci.updates
                syspci = moduleassets['pci.ids']
                msg = self._('Patching pci.ids with pci.updates found in %(packagerpm)s...' %
                            {'packagerpm':pkg.filename})
                print msg
                self.controller.patchPciIds(pkg.filename,syspci,pciupdates)
                # remove old pci.updates
                if pciupdates.exists(): pciupdates.remove()

            self.controller.extractKernelModulesDir(pkg.filename,tmpkmoddir)
        
        # generate updated modules.dep / modules.alias
        msg = self._('Generating updated modules.dep and modules.alias..')
        print msg
        tmpassetsdir = path(utiltools.mkdtemp())
        self.controller.generateModulesAssets(tmpkmoddir, tmpassetsdir)
        
        # and normalise the modules.dep
        modulesdep = tmpassetsdir / 'modules.dep'
        modulesalias = tmpassetsdir / 'modules.alias'
        if not modulesdep.exists(): 
            msg = self._('Error generating modules.dep!')
            self.printMsgExit(msg)
        
        li = self.controller.normalise_modules_dep(modulesdep)
        # write the updated modules.dep
        newmodulesdep = tmpassetsdir / 'modules.dep.new'
        f = open(newmodulesdep,'w')
        for l in li: f.write('%s\n' % l)
        f.close()
        
        modulesdep.remove()
        newmodulesdep.copy(modulesdep)
        newmodulesdep.remove()
        
        # updates the assetsdict with new modules.dep / modules.alias

        origmodulesdep = path(tmpdir / 'modules/modules.dep')
        origmodulesalias = path(tmpdir / 'modules/modules.alias')
        
        if origmodulesdep.exists(): origmodulesdep.remove()
        if origmodulesalias.exists(): origmodulesalias.remove()
        
        modulesdep.copy(origmodulesdep.dirname())
        modulesalias.copy(origmodulesalias.dirname())

        
        msg = self._('Packing kernel modules as modules archive..')
        print msg
        self.controller.convertKmodDirToModulesArchive(tmpkmoddir,oldmodulescgz, kernelrpm.getArch())
        
        if not initrdfile:
            newinitrd = nginitrd
        else:
            newinitrd = initrdfile
            
        if not kernelfile:
            kernelfile = ngkernel

        msg = self._('Packing the initrd..')
        print msg
        newinitrdpath = tftpbootdir / newinitrd
        if newinitrdpath.exists(): newinitrdpath.remove()
        self.controller.packInitrdImage(newinitrdpath,tmpdir)
        msg = self._('Initrd image saved as /tftpboot/kusu/%(initrd)s' %
                    {'initrd':newinitrd})
        print msg
        
        
        msg = self._('Extracting kernel image to /tftpboot/kusu..')
        print msg
        # expects kernelrpm filepath, not an instance of rpmtool.RPM
        kernelname = self.controller.copyKernel(kernelrpm.filename,tftpbootdir,kernelfile)
        msg = self._('Kernel image saved as /tftpboot/kusu/%(kernelname)s' %
                    {'kernelname':kernelname})
        print msg
        
        # housecleaning
        if tmpkmoddir.exists(): tmpkmoddir.rmtree()
        if tmpdir.exists(): tmpdir.rmtree()
        if tmppcidir.exists(): tmppcidir.rmtree()
        if tmpassetsdir.exists(): tmpassetsdir.rmtree()
        
        # update the kernel/initrd entries for this nodegroup if required
        if self.options.update:
            msg = self._('Updating kernel/initrd entries for this nodegroup.')
            print msg
            ngs = self.db.NodeGroups.select_by(ngname=ngname)
            ng = ngs[0]
            ng.kernel = kernelname
            ng.initrd = newinitrd
            ng.flush()
        

    def _list(self, args):
        """ Handler for list action. args is a dict of supported key-value pairs for this action. """
        ngname = args.get('name','')
        ngid = args.get('id','')


        if not ngid and not ngname:
            self.printUsageExit()
        
        if ngname:
            ngkey = 'name'
        elif ngid:
            ngkey = 'id'
            
        try:
            dpacks = self.controller.getDriverPacks(id=ngid,name=ngname)
        except ValueError:
            msg = self._('id should be a number!')
            self.printMsgExit(msg)
            
            
        if dpacks:
            msg = self._("Driverpacks belonging to nodegroup(s) matching '%(ngkey)s=%(ngval)s':" % 
                {'ngkey':ngkey,
                'ngval':ngid or ngname})
            print msg

            headers = ['name','description']
            max_lengths = []
            for x in xrange(len(headers)):
                max_lengths.append(len(headers[x]))
            
            dplines = []
            for dpack in dpacks:
                dpline = []
                dpline.append(dpack.dpname)
                dpline.append(dpack.dpdesc)
                
                # update maximum lengths
                for x in xrange(len(dpline)):
                    linelengths = [len(l) for l in dpline[x].split('\n')]
                    if max(linelengths) > max_lengths[x]:
                        max_lengths[x] = max(linelengths)

                dplines.append(dpline)
            
            printTable(headers, dplines, max_lengths)

        
if __name__ == '__main__':
	app = App()
	app.run()
	sys.exit(0)

