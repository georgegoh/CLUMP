#!/usr/bin/env python
# $Id$
#
# Copyright 2007 Platform Computing Inc.
#
# Licensed under GPL version 2; See LICENSE for details.

import sys
import os
from path import path
from kusu.core.app import KusuApp
from kusu.core import database as db
from kusu.util import tools as utiltools
from kusu.repoman import tools as repotools
from kusu.driverpatch import DriverPatchController
from kusu.util.errors import InvalidPathError, FileDoesNotExistError, InvalidArguments, \
                            UnknownKernelModuleAsset, DirDoesNotExistError, UnknownFileTypeError, \
                            RepoNotFoundError

import kusu.util.log as kusulog
kl = kusulog.getKusuLog()
kl.addFileHandler(path(os.environ.get('KUSU_TMP', '/tmp/kusu')) /
                       'kusu-driverpatch.log')
kl = kusulog.getKusuLog('driverpatch-app')

SUPPORTED_KERNEL_ARCHES = ['i586','i686','x86_64']

def printTable(titles, entries, widths):
    horline = '+'
    for width in widths:
        horline += '-' * (width + 2) + '+'

    print horline

    line = '|'
    for x in xrange(len(titles)):
        line += ' ' + titles[x].ljust(widths[x]) + ' |'

    print line
    print horline

    for entry in entries:
        newlines = True
        while newlines:
            newlines = False

            line = '|'
            for x in xrange(len(entry)):
                newline = entry[x].find('\n')
                if newline == -1:
                    thisentry = entry[x]
                    nextentry = ''
                else:
                    newlines = True
                    thisentry = entry[x][:newline]
                    nextentry = entry[x][newline + 1:]

                line += ' ' + thisentry.ljust(widths[x]) + ' |'
                entry[x] = nextentry

            print line

    print horline

        
class App(KusuApp):
    """ Application class for buildkit. """

    def __init__(self):
        """ App-specific initialization. """
        KusuApp.__init__(self)

        self.actions = {'nodegroup':['name','id','arch','version',
                        'kernel','initrd','assetsdir'], 
            'list':['name','id']}

        # self.action and self.actionargs will hold the current action and its arguments            
        self.action = None 
        self.actionargs = None
        

        self.usagestr = self._("""\
driverpatch [-h|-v] <action> arg1=val1 arg2=val2 ...

driverpatch is used to update initrd images related to nodeinstaller
deployments.


actions:

    nodegroup       - Updates the PXE kernel/initrd with the driverpacks
                      belonging to the specified nodegroup. Nodegroup
                      can be specified with name OR id:

                      REQUIRED ARGS:
                        name=<nodegroup name> | id=<nodegroup id>
                        
                      OPTIONAL ARGS:
                        arch=<arch of the kernel/initrd>
                        version=<specific kernel version to use>
                        kernel=<filepath of resulting kernel>
                        initrd=<filepath of resulting initrd>
                        assetsdir=<dir containing modules assets>
    
    list            - List the driverpacks that is associated to
                      the specified nodegroup. Nodegroup can be
                      specified with name OR id:

                      REQUIRED ARGS:
                        name=<nodegroup name> | id=<nodegroup id>

""")
        self.examples = self._("""\
Example operations:

    To patch initrds belonging to a nodegroup named compute
    # driverpatch nodegroup name=compute
    
    To patch initrds for i686 belonging to a nodegroup id of 3
    # driverpatch nodegroup id=3 arch=i686
    
    To list driverpacks that is associated to a nodegroup 
    named compute:
    # driverpatch list name=compute

    To list driverpacks that is associated to a nodegroup 
    id of 3:
    # driverpatch list id=3

""")
        self.parser.set_usage(self.usagestr)

    def printUsageExit(self):
        """ Print usage text and exit. """
        self.stdoutMessage(self.usagestr)
        sys.stdout.write(os.linesep)
        sys.exit(0)

    def printExamplesExit(self):
        """ Print examples text and exit. """
        self.stdoutMessage(self.examples)
        sys.exit(0)

    def printMsgExit(self, msg, exitcode=1):
        """ Print msg and exit. """
        self.stdoutMessage(msg)
        sys.stdout.write(os.linesep)
        sys.exit(exitcode)

    def handleArgPairs(self, arglist):
        """ Handle the argument list and return a dict of key-value pairs. """

        li = []
        d = {}

        for s in arglist:
            li2 = s.split('=')
            for s2 in li2: 
                if s2: li.append(s2)        

        # There should be even number of items in order to make pairs
        if not len(li) % 2: 
            # Collect the pairs
            while li:
                d[li[0].lower()] = li[1]
                del li[0:2]

        return d


    def parseargs(self):
        """ App-specific arguments goes here. """

        self.parser.add_option('-v','--verbose', action='store_true', dest='verbose')
        self.parser.add_option('-H','--examples', action='store_true', dest='showexamples')
        self.parser.add_option('-u','--update', action='store_true', dest='update',
                                help=self._('Update the kernel/initrd entries in database.'))
        self.parser.add_option('--dbdriver', dest='dbdriver',
                                help=self._('Database driver (sqlite, mysql)'))
        self.parser.add_option('--dbdatabase', dest='dbdatabase',
                                help=self._('Database'))
        self.parser.add_option('--dbuser', dest='dbuser',
                                help=self._('Database username'))
        self.parser.add_option('--dbpassword', dest='dbpassword',
                                help=self._('Database password'))
        self.parser.set_defaults(verbose=False,showexamples=False,update=False)
        self.options, self.args = self.parser.parse_args()


        if self.options.showexamples:
            self.printExamplesExit()

        if len(self.args) < 2:
            self.printUsageExit()


        # check if the first parsed argument is a supported action
        action = self.args[0]


        if action not in self.actions.keys():
            self.printUsageExit()
        d = self.handleArgPairs(self.args[1:])

        if not d:
            self.printUsageExit()

        # iterate keys in d and validate against the commands'
        # list of keys
        for k in d.keys():
            if k not in self.actions[action]:
                self.printUsageExit()

        self.action = action
        self.actionargs = d

    def run(self):
        """ Main launcher. """
        self.parseargs()

        # get the db instance
        dbdriver = 'mysql'
        dbdatabase = 'kusudb'
        dbuser = 'apache'
        dbpassword = None
        if self.options.dbdriver:
            dbdriver = self.options.dbdriver
        if self.options.dbdatabase:
            dbdatabase = self.options.dbdatabase
        if self.options.dbuser:
            dbuser = self.options.dbuser
        if self.options.dbpassword:
            dbpassword = self.options.dbpassword


        self.db = db.DB(dbdriver, dbdatabase, dbuser, dbpassword)

        # an instance of the controller for managing the actions        
        self.controller = DriverPatchController(self.db)

        # set verbosity
        self.verbose = self.options.verbose

        # call the correct sub-handler for the action
        m = '_' + self.action.split('-')[0] \
            + ''.join([l.capitalize() for l in self.action.split('-')[1:]])

        handler = getattr(self,m)

        handler(self.actionargs)
    
    def _nodegroup(self, args):
        """ Handler for nodegroup action. args is a dict of supported key-value pairs for this action. """
        ngname = args.get('name','')
        ngid = args.get('id','')
        karch = args.get('arch','')
        kver = args.get('version','')
        kernelfile = args.get('kernel','')
        initrdfile = args.get('initrd','')
        assetsdir = args.get('assetsdir','')
        
        if not ngid and not ngname:
            self.printUsageExit()
            
        #if not karch:
        #    self.printUsageExit()
            
        #if not karch in SUPPORTED_KERNEL_ARCHES:
        #    msg = self._('Arch %(karch)s not supported!' %
        #                {'karch':karch})
        #    self.printMsgExit(msg)
        
        if ngname:
            ngkey = 'name'
        elif ngid:
            ngkey = 'id'
            
        # get the ngname
        if ngkey == 'id':
            try:
                _ngid = long(ngid)
            except ValueError:
                msg = self._('id should be a number!')
                self.printMsgExit(msg)
            
            _ng = self.db.NodeGroups.select_by(ngid=_ngid)
            if _ng:
                ng = _ng[0]
                ngname = ng.ngname
            else:
                msg = self._('Nodegroup not found!')
                self.printMsgExit(msg)
    
        else:
            # validate the supplied ngname
            _ng = self.db.NodeGroups.select_by(ngname=ngname)
            if not _ng:
                msg = self._('Nodegroup not found!')
                self.printMsgExit(msg)

            
        # get the available driverpacks
        try:
            dpacks = self.controller.getDriverPacks(id=ngid,name=ngname)
        except ValueError:
            msg = self._('id should be a number!')
            self.printMsgExit(msg)
            
        if not dpacks:
            msg = self._('No valid driverpacks found.')
            self.printMsgExit(msg)
                    
        # get the correct dpacks
        #dprpms = [dpack.dpname for dpack in dpacks if dpack.dpname.find(karch) >-1]
        dprpms = [dpack.dpname for dpack in dpacks]

        if not dprpms:
            msg = self._('No valid driverpacks found.')
            self.printMsgExit(msg)            
        
        for dprpm in dprpms:
            msg = self._('Found valid driverpack: %(dpname)s' %
                        {'dpname':dprpm})
            print msg
            
        # get the repoid for this nodegroup
        if not repotools.repoForNodeGroupExists(self.db,ngname):
            msg = self._('No valid repo available this nodegroup!')
            self.printMsgExit(msg)
            
        repoid = repotools.getRepoFromNodeGroup(self.db,ngname)
        repos = self.db.Repos.select_by(repoid=repoid)
        repo = repos[0].repository
        if not repo:
            msg = self._('No valid repo available for this nodegroup!')
            self.printMsgExit(msg)
            
        msg = self._('Looking in %(repository)s..' %
                    {'repository':repo})
        print msg
        
        # lets get the driverpacks packages
        pkglist = []
        for dprpm in dprpms:
            try:
                pkg = repotools.getPackageFilePath(self.db,repoid,dprpm)
                pkglist.append(pkg)
            except RepoNotFoundError:
                msg = self._('No valid repo available for this nodegroup!')
                self.printMsgExit(msg)
            except FileDoesNotExistError:
                msg = self._('%(pkgname)s not available in for the repo belong to this nodegroup!' %
                            {'pkgname':dprpm})
                self.printMsgExit(msg)
                
        for pkg in pkglist:
            msg = self._('Found %(pkgname)s..' %
                        {'pkgname':pkg})
            print msg
        
        tftpbootdir = path('/tftpboot/kusu')
        if not tftpbootdir.exists():
            msg = self._('/tftpboot/kusu not found! Aborting operation.')
            self.printMsgExit(msg)
        
        # get the kernel rpm
        # FIXME: There has to be a better way of identifying distro package kernels!
        li = [pkg for pkg in pkglist if pkg.find('kernel-') > -1]
        if not li:
            msg = self._('Kernel rpm not found!')
            self.printMsgExit(msg)
            
        kernelrpm = li[0]
        
        # get the current kernel/initrd for this nodegroup
        _ng = self.db.NodeGroups.select_by(ngname=ngname)

        # FIXME: Ensure the ngedit has not updated the kernel/initrd fields!
        ngkernel = _ng[0].kernel
        nginitrd = _ng[0].initrd

        tmpdir = path(utiltools.mkdtemp())

        # get the existing initrd
        initrdpath = tftpbootdir / nginitrd
        if not initrdpath.exists():
            msg = self._('Current initrd %(initrdpath)s not found! Aborting operation!' %
                        {'initrdpath':initrdpath})
            self.printMsgExit(msg)
            
        self.controller.unpackInitrdImage(initrdpath,tmpdir)
        # get the modules cgz
        oldmodulescgz = self.controller.getKernelModulesCgz(tmpdir)
        oldmodulescgz.remove()
        
        msg = self._('Extracting kernel modules from package..')
        print msg
        tmpkmoddir = path(utiltools.mkdtemp())
        self.controller.extractKernelModulesDir(kernelrpm,tmpkmoddir)
        
        # get kver and arch from the modulesdir
        _kver = self.controller.getKernelVersion(tmpkmoddir)
        _karch = self.controller.getKernelArch(tmpkmoddir)
        
        # validate version
        if kver:
            if _kver <> kver:
                msg = self._('The kernel version in package does not match %(kver)s! Aborting operation!' %
                            {'kver':kver})
                            
                if tmpkmoddir.exists(): tmpkmoddir.rmtree()
                if tmpdir.exists(): tmpdir.rmtree()
                self.printMsgExit(msg)
            
        # validate arch
        #if _karch <> karch:
        #    msg = self._('The kernel arch in package does not match %(karch)s! Aborting operation!' %
        #                {'karch':karch})
                        
        #    if tmpkmoddir.exists(): tmpkmoddir.rmtree()
        #    if tmpdir.exists(): tmpdir.rmtree()
        #    self.printMsgExit(msg)        
        
        msg = self._('Packing kernel modules as modules archive..')
        print msg
        self.controller.convertKmodDirToModulesArchive(tmpkmoddir,oldmodulescgz)
        
        if not initrdfile:
            newinitrd = '-'.join(['initrd',_kver,_karch])
        else:
            newinitrd = initrdfile
            
        # TODO: Handle the module assets here!
        #self.controller.updateKernelModulesAssets(foo)

        msg = self._('Packing the initrd..')
        print msg
        newinitrdpath = tftpbootdir / newinitrd
        if newinitrdpath.exists(): newinitrdpath.remove()
        self.controller.packInitrdImage(newinitrdpath,tmpdir)
        msg = self._('Initrd image saved as /tftpboot/kusu/%(initrd)s' %
                    {'initrd':newinitrd})
        print msg
        
        
        msg = self._('Extracting kernel image to /tftpboot/kusu..')
        print msg
        kernelname = self.controller.copyKernel(kernelrpm,tftpbootdir,kernelfile)
        msg = self._('Kernel image saved as /tftpboot/kusu/%(kernelname)s' %
                    {'kernelname':kernelname})
        print msg
        
        # housecleaning
        if tmpkmoddir.exists(): tmpkmoddir.rmtree()
        if tmpdir.exists(): tmpdir.rmtree()

        # update the kernel/initrd entries for this nodegroup if required
        if self.options.update:
            msg = self._('Updating kernel/initrd entries for this nodegroup.')
            print msg
            ngs = self.db.NodeGroups.select_by(ngname=ngname)
            ng = ngs[0]
            ng.kernel = kernelname
            ng.initrd = newinitrd
            ng.flush()
        

    def _list(self, args):
        """ Handler for list action. args is a dict of supported key-value pairs for this action. """
        ngname = args.get('name','')
        ngid = args.get('id','')


        if not ngid and not ngname:
            self.printUsageExit()
        
        if ngname:
            ngkey = 'name'
        elif ngid:
            ngkey = 'id'
            
        try:
            dpacks = self.controller.getDriverPacks(id=ngid,name=ngname)
        except ValueError:
            msg = self._('id should be a number!')
            self.printMsgExit(msg)
            
            
        if dpacks:
            msg = self._("Driverpacks belonging to nodegroup(s) matching '%(ngkey)s=%(ngval)s':" % 
                {'ngkey':ngkey,
                'ngval':ngid or ngname})
            print msg

            headers = ['name','description']
            max_lengths = []
            for x in xrange(len(headers)):
                max_lengths.append(len(headers[x]))
            
            dplines = []
            for dpack in dpacks:
                dpline = []
                dpline.append(dpack.dpname)
                dpline.append(dpack.dpdesc)
                
                # update maximum lengths
                for x in xrange(len(dpline)):
                    linelengths = [len(l) for l in dpline[x].split('\n')]
                    if max(linelengths) > max_lengths[x]:
                        max_lengths[x] = max(linelengths)

                dplines.append(dpline)
            
            printTable(headers, dplines, max_lengths)

        
if __name__ == '__main__':
	app = App()
	app.run()
	sys.exit(0)

