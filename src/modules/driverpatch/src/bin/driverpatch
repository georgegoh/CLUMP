#!/usr/bin/env python
# $Id$
#
# Copyright 2007 Platform Computing Inc.
#
# Licensed under GPL version 2; See LICENSE for details.

import sys
import os
from path import path
from kusu.core.app import KusuApp
from kusu.core import database as db
from kusu.driverpatch import DriverPatchController

import kusu.util.log as kusulog
kl = kusulog.getKusuLog()
kl.addFileHandler(path(os.environ.get('KUSU_TMP', '/tmp/kusu')) /
                       'kusu-driverpatch.log')
kl = kusulog.getKusuLog('driverpatch-app')

def printTable(titles, entries, widths):
    horline = '+'
    for width in widths:
        horline += '-' * (width + 2) + '+'

    print horline

    line = '|'
    for x in xrange(len(titles)):
        line += ' ' + titles[x].ljust(widths[x]) + ' |'

    print line
    print horline

    for entry in entries:
        newlines = True
        while newlines:
            newlines = False

            line = '|'
            for x in xrange(len(entry)):
                newline = entry[x].find('\n')
                if newline == -1:
                    thisentry = entry[x]
                    nextentry = ''
                else:
                    newlines = True
                    thisentry = entry[x][:newline]
                    nextentry = entry[x][newline + 1:]

                line += ' ' + thisentry.ljust(widths[x]) + ' |'
                entry[x] = nextentry

            print line

    print horline

        
class App(KusuApp):
    """ Application class for buildkit. """

    def __init__(self):
        """ App-specific initialization. """
        KusuApp.__init__(self)

        self.actions = {'nodegroup':['name','id'], 
            'list':['name','id']}

        # self.action and self.actionargs will hold the current action and its arguments            
        self.action = None 
        self.actionargs = None
        

        self.usagestr = self._("""\
driverpatch [-h|-v] <action> arg1=val1 arg2=val2 ...

driverpatch is used to update initrd images related to nodeinstaller
deployments.


actions:

    nodegroup       - Refresh the initrd images with the driverpacks
                      belonging to the specified nodegroup. Nodegroup
                      can be specified with name OR id:

                      REQUIRED ARGS:
                        name=<nodegroup name> | id=<nodegroup id>
    
    list            - List the driverpacks that is associated to
                      the specified nodegroup. Nodegroup can be
                      specified with name OR id:

                      REQUIRED ARGS:
                        name=<nodegroup name> | id=<nodegroup id>

""")
        self.examples = self._("""\
Example operations:

    To patch initrds belonging to a nodegroup named compute
    # driverpatch nodegroup name=compute
    
    To patch initrds belonging to a nodegroup id of 3
    # driverpatch nodegroup id=3
    
    To list driverpacks that is associated to a nodegroup 
    named compute:
    # driverpatch list name=compute

    To list driverpacks that is associated to a nodegroup 
    id of 3:
    # driverpatch list id=3

""")
        self.parser.set_usage(self.usagestr)

    def printUsageExit(self):
        """ Print usage text and exit. """
        self.stdoutMessage(self.usagestr)
        sys.stdout.write(os.linesep)
        sys.exit(0)

    def printExamplesExit(self):
        """ Print examples text and exit. """
        self.stdoutMessage(self.examples)
        sys.exit(0)

    def printMsgExit(self, msg, exitcode=1):
        """ Print msg and exit. """
        self.stdoutMessage(msg)
        sys.stdout.write(os.linesep)
        sys.exit(exitcode)

    def handleArgPairs(self, arglist):
        """ Handle the argument list and return a dict of key-value pairs. """

        li = []
        d = {}

        for s in arglist:
            li2 = s.split('=')
            for s2 in li2: 
                if s2: li.append(s2)        

        # There should be even number of items in order to make pairs
        if not len(li) % 2: 
            # Collect the pairs
            while li:
                d[li[0].lower()] = li[1]
                del li[0:2]

        return d


    def parseargs(self):
        """ App-specific arguments goes here. """

        self.parser.add_option('-v','--verbose', action='store_true', dest='verbose')
        self.parser.add_option('-H','--examples', action='store_true', dest='showexamples')
        self.parser.add_option('--dbdriver', dest='dbdriver',
                                help=self._('Database driver (sqlite, mysql)'))
        self.parser.add_option('--dbdatabase', dest='dbdatabase',
                                help=self._('Database'))
        self.parser.add_option('--dbuser', dest='dbuser',
                                help=self._('Database username'))
        self.parser.add_option('--dbpassword', dest='dbpassword',
                                help=self._('Database password'))
        self.parser.set_defaults(verbose=False,showexamples=False)
        self.options, self.args = self.parser.parse_args()


        if self.options.showexamples:
            self.printExamplesExit()

        if len(self.args) < 2:
            self.printUsageExit()


        # check if the first parsed argument is a supported action
        action = self.args[0]


        if action not in self.actions.keys():
            self.printUsageExit()
        d = self.handleArgPairs(self.args[1:])

        if not d:
            self.printUsageExit()

        # iterate keys in d and validate against the commands'
        # list of keys
        for k in d.keys():
            if k not in self.actions[action]:
                self.printUsageExit()

        self.action = action
        self.actionargs = d

    def run(self):
        """ Main launcher. """
        self.parseargs()

        # get the db instance
        dbdriver = 'mysql'
        dbdatabase = 'kusudb'
        dbuser = 'apache'
        dbpassword = None
        if self.options.dbdriver:
            dbdriver = self.options.dbdriver
        if self.options.dbdatabase:
            dbdatabase = self.options.dbdatabase
        if self.options.dbuser:
            dbuser = self.options.dbuser
        if self.options.dbpassword:
            dbpassword = self.options.dbpassword


        self.db = db.DB(dbdriver, dbdatabase, dbuser, dbpassword)

        # an instance of the controller for managing the actions        
        self.controller = DriverPatchController(self.db)

        # set verbosity
        self.verbose = self.options.verbose

        # call the correct sub-handler for the action
        m = '_' + self.action.split('-')[0] \
            + ''.join([l.capitalize() for l in self.action.split('-')[1:]])

        handler = getattr(self,m)

        handler(self.actionargs)
    
    def _nodegroup(self, args):
        """ Handler for nodegroup action. args is a dict of supported key-value pairs for this action. """
        ngname = args.get('name','')
        ngid = args.get('id','')
        
        if not ngid and not ngname:
            self.printUsageExit()
        
        if ngname:
            ngkey = 'name'
        elif ngid:
            ngkey = 'id'
            
        

    def _list(self, args):
        """ Handler for list action. args is a dict of supported key-value pairs for this action. """
        ngname = args.get('name','')
        ngid = args.get('id','')

        if not ngid and not ngname:
            self.printUsageExit()
        
        if ngname:
            ngkey = 'name'
        elif ngid:
            ngkey = 'id'
            
        try:
            dpacks = self.controller.getDriverPacks(id=ngid,name=ngname)
        except ValueError:
            msg = self._('id should be a number!')
            self.printMsgExit(msg)
            
            
        if dpacks:
            msg = self._("Driverpacks belonging to nodegroup(s) matching '%(ngkey)s=%(ngval)s':" % 
                {'ngkey':ngkey,
                'ngval':ngid or ngname})
            print msg

            headers = ['name','description']
            max_lengths = []
            for x in xrange(len(headers)):
                max_lengths.append(len(headers[x]))
            
            dplines = []
            for dpack in dpacks:
                dpline = []
                dpline.append(dpack.dpname)
                dpline.append(dpack.dpdesc)
                
                # update maximum lengths
                for x in xrange(len(dpline)):
                    linelengths = [len(l) for l in dpline[x].split('\n')]
                    if max(linelengths) > max_lengths[x]:
                        max_lengths[x] = max(linelengths)

                dplines.append(dpline)
            
            printTable(headers, dplines, max_lengths)

        
if __name__ == '__main__':
	app = App()
	app.run()
	sys.exit(0)

