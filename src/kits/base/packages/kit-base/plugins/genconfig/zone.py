# $Id: zone.py 3420 2010-01-25 09:48:45Z ankit $
#
#   Copyright 2007 Platform Computing Inc
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of version 2 of the GNU General Public License as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
#
#

import sys
import string
import time
from kusu.genconfig import Report

class thisReport(Report):

    def toolHelp(self):
        """toolHelp - This method provides the help screen for this particular
        plugin.  All plugins must implement this method."""
        print self.gettext("genconfig_Zone_Help")


    def runPlugin(self, pluginargs):
        """runPlugin - This method provides the database report for this
        plugin.  All plugins must implement this method."""

        _ = self.gettext

        # Test to see if the Installer node should be running DNS.
        dnsenabled = self.db.getAppglobals('InstallerServeDNS')
        if dnsenabled != '1':
            return True

        # Get the name of the primary installer
        primaryinst = self.db.getAppglobals('PrimaryInstaller')
        if not primaryinst:
            sys.stderr.write(_("genconfig_cannot_determine_primary_installer\n"))
            return False

        # Get the DNS Zone served by the Installer
        dnszone = self.db.getAppglobals('DNSZone')
        if not dnszone:
            sys.stderr.write(_("genconfig_cannot_determine_DNS_zone\n"))
            return False

        # Get the name of the primary mail server
        mailserv = self.db.getAppglobals('SMTPServer')
        if not mailserv:
            servesmtp = self.db.getAppglobals('InstallerServeSMTP')
            if servesmtp == 'True':
                mailserv = '%s.%s' % (primaryinst, dnszone)

        # Generate the file contents
        print "; "
        print "; Dynamically generated by: genconfig  (Do not edit!)"
        print "; "
        print '; Zone file %s.zone for: %s' % (dnszone, dnszone)
        print '$TTL 2d    ; 172800 secs default TTL for zone'
        print '@\t\tIN\tSOA\t%s.%s. root.%s. (' % (primaryinst, dnszone, dnszone)
        tmp = '%f' % time.time()
        serial = string.split(tmp, '.')[0]
        print '\t\t\t%s\t; Serial number' % serial
        print '\t\t\t4h\t; Refresh'
        print '\t\t\t15m\t; Update retry time'
        print '\t\t\t24h\t; Expiry time'
        print '\t\t\t1d\t; Minimum TTL'
        print '\t\t\t)'

        # Print out all the NS entries, exclude the public nic
        query = ('select nodes.name, nics.ip, networks.suffix '
                 'from nodes, nics, networks '
                 'where nodes.ngid=1 and nodes.nid=nics.nid and networks.netid=nics.netid '
                 'and networks.usingdhcp=False and networks.type<>"public"')
        try:
            self.db.execute(query)

        except:
            sys.stderr.write(_("DB_Query_Error\n"))
            return False

        data = self.db.fetchall()

        if data:
            for row in data:
                dnsname, ip, nssuffix = row
                print '\t\tIN\tNS\t%s%s.%s.' % (dnsname, nssuffix or '', dnszone)
        else:
            sys.stderr.write("Warning:  No private NS records in PCM domain: %s!\n", dnszone)

        if mailserv != '':
            print '\t\tIN\tMX  50  %s.' % mailserv
        print ''

        #got the unmanaged node group id
        umngid = self.db.getNgidOf('unmanaged')

        # Print out all installer node group names
        query = ('select nodes.name,nics.ip,networks.suffix,networks.type,nics.boot,nodes.ngid '
                 'from nodes,nics,networks '
                 'where nodes.nid=nics.nid and nics.netid=networks.netid '
                 'and networks.usingdhcp=False and networks.type<>"public" '
                 'order by nodes.name, networks.device')
        try:
            self.db.execute(query)

        except:
            sys.stderr.write(_("DB_Query_Error\n"))
            return False

        prev_dns_name = ''             #the previous dnsname
        written_short_name = False       #already give short name flag
        data = self.db.fetchall() or []
        for row in data:
            dnsname, ip, suffix, nettype, boot, ngid = row

            if umngid == ngid:
                #unmanaged node without suffix
                print '%s\tIN\tA\t%s' % (dnsname, ip)
            else:
                if prev_dns_name != dnsname:
                    written_short_name = False
                    prev_dns_name = dnsname
                #Add the short name when it's bootable(compute-node) and in provision net
                #only add one short name, sorted by device name
                if not written_short_name and self._is_name_short(nettype, suffix, (boot or ngid==1)):
                    print '%s\tIN\tA\t%s' % (dnsname, ip)
                    written_short_name = True

                    if suffix:
                        print '%s%s\tIN\tCNAME\t%s' % (dnsname, suffix, dnsname)

                else:
                    print '%s%s\tIN\tA\t%s' % (dnsname, suffix or '', ip)

    def _is_name_short(self, nettype, suffix, boot):
        #check the nics can be short name
        return nettype == 'provision' and suffix != '-bmc' and boot
