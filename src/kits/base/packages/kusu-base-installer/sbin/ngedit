#!/usr/bin/env python
#
# $Id$
#
# Node Group Editor
#
# Copyright 2007 Platform Computing Inc.
#
# Licensed under GPL version 2; See LICENSE file for details.
#
# Author: Alexey Tumanov (atumanov)

import snack
import sys
import os
import glob
import string
import re
import subprocess
import tempfile
import shutil
from sets import Set
from kusu.ui.text.USXscreenfactory import USXBaseScreen,ScreenFactory
from kusu.ui.text.USXnavigator import *
from kusu.ui.text import USXkusuwidgets as kusuwidgets
from kusu.core.app import KusuApp
from kusu.core.db import KusuDB
from kusu.ngedit.ngedit import *
from kusu.ngedit.partition import *

import kusu.util.log as kusulog
kl = kusulog.getKusuLog()
kl.addFileHandler(os.environ.get('KUSU_TMP', '/tmp/kusu') + "/kusu-ngedit.log")
kl = kusulog.getKusuLog('ngedit')

global curNG, origNG

MAXWIDTH = 70
MAXHEIGHT = 18
LEFT=kusuwidgets.LEFT
CENTER=kusuwidgets.CENTER
RIGHT=kusuwidgets.RIGHT
CustomScriptDir = "/depot/repos/custom_scripts/"

class scrNGEMain(USXBaseScreen):
    name= 'Node Group Editor'
    msg = 'Select the Node Group to operate on from the list below'
    buttons = ['edit_button', 'copy_button', 'delete_button', 'exit_button']

    def __init__(self, database, kusuApp=None, gridWidth=45):
        USXBaseScreen.__init__(self, database, kusuApp=kusuApp, gridWidth=gridWidth)
        self.setHelpLine('Select the Node Group to operate on and choose desired operation')
        self.__nglistbox = None

    def setCallbacks(self):

        #for the buttons
        self.buttonsDict['edit_button'].setCallback_(self.doEditAction)
        self.buttonsDict['copy_button'].setCallback_(self.doCopyAction)
        self.buttonsDict['delete_button'].setCallback_(self.doDeleteAction)
        #for hotkeys
        self.hotkeysDict['F12'] = self.F12Action

    def F12Action(self):
        return NAV_IGNORE

    def doCopyAction(self):

        ngid = self.__nglistbox.current()

        if ngid == 1:
            self.selector.popupMsg('Operation Disallowed', 'Installer nodegroup'+\
                                   ' is not allowed to be copied')
            return NAV_NOTHING
            
        newNG = NodeGroup(ngid = ngid)
        newNG.syncFromDB(self.database)
        kl.debug("Copy Action performed. new NG record:\n%s" %str(newNG))
        newNG['ngid'] = None    #give it new identity


        query = "select ngname from nodegroups where ngname like '%s Copy %%'" %newNG['ngname']
        self.database.execute(query)
        rv = self.database.fetchall()
        if rv == ():
            suffix = 1
        else:
            suffix = int(max(filter((lambda x: x.isdigit()), [string.split(x[0])[-1] for x in rv]))) + 1
        ngname = '%s Copy %s' %(newNG['ngname'], suffix)
        newNG['ngname'] = ngname

        newNG.syncToDB(self.database)
       
        return NAV_NOTHING

    def doDeleteAction(self):
        ngid = self.__nglistbox.current()

        #TODO: check if the nodegroup is in use by any nodes

        tmpNG = NodeGroup(ngid = ngid)
        tmpNG.syncFromDB(self.database) #to get all the links
        msg = "You are about to delete the selected nodegroup. Do you wish to proceed?"
        rv = self.selector.popupYesNo('Node Group Deletion Alert', msg, defaultNo=True)
        if rv:
            tmpNG.eraseFromDB(self.database)

        return NAV_NOTHING

    def doEditAction(self, data=None):
        global curNG,origNG

        ngid = self.__nglistbox.current()
        curNG = NodeGroup(ngid=ngid)
        curNG.syncFromDB(self.database)

        #replace all Null values
        for f in NodeGroup.fields[1:]:
            if curNG[f] == None:
                curNG[f] = ''

        #work around Kusu bug 347
        if curNG['parts']:
            for p in curNG['parts']:
                if p['options'] == None:
                    p['options'] = ''
                if p['mntpnt'] == None:
                    p['mntpnt'] = ''
                if p['device'] == None:
                    p['device'] = ''


        origNG = curNG.copy()
        assert(curNG == origNG)

        #pass on the db and kusuApp handles to other screens
        #they will all share one instance of each
        ScreenFactory.screens = [
                                 scrNGEEdit_General(database=self.database, kusuApp=self.kusuApp),
                                 scrNGEEdit_Repo(database=self.database, kusuApp=self.kusuApp),
                                 scrNGEEdit_Boot(database=self.database, kusuApp=self.kusuApp),
                                 scrNGEEdit_Components(database=self.database, kusuApp=self.kusuApp),
                                 scrNGEEdit_Networks(database=self.database, kusuApp=self.kusuApp),
                                 scrNGEEdit_Packages(database=self.database, kusuApp=self.kusuApp),
                                 scrNGEEdit_Modules(database=self.database, kusuApp=self.kusuApp),
                                 scrNGEEdit_Scripts(database=self.database, kusuApp=self.kusuApp),
                                 scrNGEEdit_PartSchema(database=self.database, kusuApp=self.kusuApp),
                                 scrNGEEdit_Finalize(database=self.database, kusuApp=self.kusuApp),
                                ]

        ks = USXNavigator(screenFactory=ScreenFactory, screenTitle="Node Group Edit", showTrail=False)
        ks.run()

        return NAV_NOTHING

    def drawImpl(self):

        cols = [ ['NODE GROUP', 'DESCRIPTION'] ]
        self.database.execute('''select max(char_length(ngname)), max(char_length(ngdesc))
                                 from nodegroups''')
        rv = self.database.fetchone()
        rv = [ ifelse(x==None,0,x) for x in rv ] #replace all Null values
        cols.append([int(x) for x in rv]) #justification values

        headstr = ''
        for i in xrange(len(cols[0])): #for all columns
            cols[1][i] = max(cols[1][i], len(cols[0][i]))+1 #make room for the label
            headstr += cols[0][i].ljust(cols[1][i])
        if len(headstr) > MAXWIDTH:
            headstr = headstr[:MAXWIDTH]

        lblheader = snack.Label(headstr)
        self.__nglistbox = snack.Listbox(height=10, scroll=1, width=MAXWIDTH,returnExit=1, showCursor=0)

        self.database.execute('select ngname,ngdesc,ngid from nodegroups')
        rv = self.database.fetchall()
        #Null value replacement magic
        rv = [ ifelse(None in x, [ ifelse(y==None,'',y) for y in x ] , list(x)) for x in rv ]

        for record in rv:
            ngid = record.pop()
            entrystr = ''
            for i in xrange(len(record)): #construct an entry string
                entrystr += record[i].ljust(cols[1][i])
            if len(entrystr) > MAXWIDTH:
                entrystr = entrystr[:MAXWIDTH - len('...')] + '...'

            self.__nglistbox.append(entrystr, item = ngid)

        self.screenGrid = snack.Grid(1, 2)
        self.screenGrid.setField(lblheader, 0,0, padding=(0,0,0,0), growx=1,anchorLeft=1)
        self.screenGrid.setField(self.__nglistbox, 0,1, padding=(0,0,0,0), growx=1)


    def validate(self):
        """Validation code goes here. Activated when 'Next' button is pressed."""
        return True, 'Success'

    def formAction(self):
        ''' Actions taken once the form data was successfully validated.
            Timeline: Next_callback, validation, formAction
        '''
        pass

#end class scrNGEMain

class scrNGEEdit_General(USXBaseScreen):
    name = 'General Info'
    msg = 'General Info about the selected node'
    buttons = ['next_button', 'cancel_button']

    def __init__(self, database, kusuApp=None, gridWidth=45):
        USXBaseScreen.__init__(self, database, kusuApp=kusuApp, gridWidth=gridWidth)

    def setCallbacks(self):

        #for the buttons
        self.buttonsDict['next_button'].setCallback_(self.doForwardAction)
        self.buttonsDict['cancel_button'].setCallback_(self.doCancelAction)

    def doCancelAction(self):
        return NAV_QUIT

    def doForwardAction(self):
        return NAV_FORWARD

    def drawImpl(self):

        labeltxt1 = 'Node Group Name: '
        labeltxt2 = 'Node Group Desc: '
        labeltxt3 = 'Node Name Format: '

        labellen = max(len(labeltxt1), len(labeltxt2), len(labeltxt3))

        self.__entries = {}
        self.__entries['ngname'] = kusuwidgets.LabelledEntry(labelTxt=labeltxt1.rjust(labellen),\
                     text = curNG['ngname'], width=30, password=0, returnExit = 0)
        self.__entries['ngdesc'] = kusuwidgets.LabelledEntry(labelTxt=labeltxt2.rjust(labellen),\
                     text = curNG['ngdesc'], width=30, password=0, returnExit = 0)
        self.__entries['nameformat'] = kusuwidgets.LabelledEntry(labelTxt=labeltxt3.rjust(labellen),\
                     text = curNG['nameformat'], width=30, password=0, returnExit = 0)
 
        self.screenGrid = snack.Grid(1, 3)
        self.screenGrid.setField(self.__entries['ngname'], col=0,row=0)
        self.screenGrid.setField(self.__entries['ngdesc'], col=0,row=1)
        self.screenGrid.setField(self.__entries['nameformat'], col=0,row=2)

    def validate(self):
        """Validation code goes here. Activated when 'Next' button is pressed."""
        #TODO: ensure uniqueness of ngname
        return True, 'Success'

    def formAction(self):
        ''' Actions taken once the form data was successfully validated.
            Timeline: Next_callback, validation, formAction
        '''
        #update curNG with entry values
        curNG['ngname'] = self.__entries['ngname'].value()
        curNG['ngdesc'] = self.__entries['ngdesc'].value()
        curNG['nameformat'] = self.__entries['nameformat'].value()
        

class scrNGEEdit_Repo(USXBaseScreen):
    name = 'Repository'
    msg = 'Repository selection for the Node Group specified'
    buttons = ['next_button', 'back_button', 'cancel_button']

    def __init__(self, database, kusuApp=None, gridWidth=45):
        USXBaseScreen.__init__(self, database, kusuApp=kusuApp, gridWidth=gridWidth)

    def setCallbacks(self):

        #for the buttons
        self.buttonsDict['next_button'].setCallback_(self.doForwardAction)
        self.buttonsDict['back_button'].setCallback_(self.doBackAction)
        self.buttonsDict['cancel_button'].setCallback_(self.doQuitAction)

    def doQuitAction(self):
        return NAV_QUIT

    def doForwardAction(self):
        return NAV_FORWARD

    def doBackAction(self):
        return NAV_BACK

    def drawImpl(self):

        cols = [ ['RepoName','Repository','OSType'] ]

        #extract all possible repos from table 'repos' and display
        self.database.execute('''select max(char_length(reponame)),max(char_length(repository))
                                 , max(char_length(ostype)) from repos''')
        rv = self.database.fetchone()
        rv = [ ifelse(x==None,0,x) for x in rv ]
        cols.append([int(x) for x in rv]) #justification values

        headstr = ''
        for i in xrange(len(cols[0])):
            cols[1][i] = max(cols[1][i], len(cols[0][i])) + 1
            headstr += cols[0][i].ljust(cols[1][i])
        if len(headstr) > MAXWIDTH:
            headstr = headstr[:MAXWIDTH]

        lblheader = snack.Label(headstr)
        self.__repolistbox = snack.Listbox(height=10,scroll=1,width=MAXWIDTH,returnExit=1,showCursor=0)

        self.database.execute('select reponame,repository,ostype,repoid from repos')
        rv = self.database.fetchall()
        rv = [ ifelse(None in x, [ ifelse(y==None,'',y) for y in x ] , list(x)) for x in rv ]

        for record in rv:
            repoid = record.pop()
            entrystr = ''
            for i in xrange(len(record)):
                entrystr += record[i].ljust(cols[1][i])
            if len(entrystr) > MAXWIDTH:
                entrystr = entrystr[:MAXWIDTH - len('...')] + '...'
            self.__repolistbox.append(entrystr, item = repoid)
            if repoid == curNG['repoid']:
                self.__repolistbox.setCurrent(repoid)

        self.screenGrid = snack.Grid(1, 2)
        self.screenGrid.setField(lblheader, 0,0, (0,0,0,0), growx=1, anchorLeft=1)
        self.screenGrid.setField(self.__repolistbox, 0,1, (0,0,0,0), growx=1)


    def validate(self):
        """Validation code goes here. Activated when 'Next' button is pressed."""
        return True, 'Success'

    def formAction(self):
        ''' Actions taken once the form data was successfully validated.
            Timeline: Next_callback, validation, formAction
        '''
        curNG['repoid'] = self.__repolistbox.current()



class scrNGEEdit_Boot(USXBaseScreen):
    name = 'Boot Time Parameters'
    msg = 'Boot Time Parameters'
    buttons = ['next_button', 'back_button', 'cancel_button']

    def __init__(self, database, kusuApp=None, gridWidth=45):
        USXBaseScreen.__init__(self, database, kusuApp=kusuApp, gridWidth=gridWidth)

    def setCallbacks(self):

        #for the buttons
        self.buttonsDict['next_button'].setCallback_(self.doForwardAction)
        self.buttonsDict['back_button'].setCallback_(self.doBackAction)
        self.buttonsDict['cancel_button'].setCallback_(self.doCancelAction)
        self.hotkeysDict['F12'] = self.F12Action

    def F12Action(self):
        self.selector.popupMsg('debug info','installtype = %s' %str(curNG['installtype']))
        return NAV_IGNORE

    def doBackAction(self):
        return NAV_BACK

    def doCancelAction(self):
        return NAV_QUIT

    def doForwardAction(self):
        return NAV_FORWARD

    def drawImpl(self):

        installtype = {'package':'Package Based', 'diskless':'Diskless', 
                       'disked': 'Imaged Disked'
                      }
        self.screenGrid = snack.Grid(2, 3)

        lbl1 = snack.Label('Kernel: ')
        lbl2 = snack.Label('Kernel Params: ')
        lbl3 = snack.Label('Install Type: ')
        w = min(max(len(curNG['kernel']), len(curNG['kparams']))+1, 60)
        self.__entries = {}
        self.__entries['kernel'] = snack.Entry(width=w, text=curNG['kernel'])
        self.__entries['kparams'] = snack.Entry(width=w, text=curNG['kparams'])

        rblist = []
        for key,val in installtype.items():
            isOn = int(curNG['installtype'] == key) #cast bool to int
            rblist.append((val,key,isOn))

        self.__InstallTypeRb = snack.RadioBar(self.screen, rblist)

        self.screenGrid.setField(lbl1,0,0,anchorRight=1)
        self.screenGrid.setField(lbl2,0,1,anchorRight=1)
        self.screenGrid.setField(lbl3,0,2,(0,1,0,0),anchorRight=1)
        self.screenGrid.setField(self.__entries['kernel'], 1,0,anchorLeft=1)
        self.screenGrid.setField(self.__entries['kparams'],1,1,anchorLeft=1)
        self.screenGrid.setField(self.__InstallTypeRb,1,2,(0,1,0,0),anchorLeft=1)

    def validate(self):
        return True, 'Success'

    def formAction(self):
        ''' Actions taken once the form data was successfully validated.
            Timeline: drawImpl, Next_callback, validation, formAction
        '''
        curNG['kernel'] = self.__entries['kernel'].value()
        curNG['kparams'] = self.__entries['kparams'].value()
        curNG['installtype'] = self.__InstallTypeRb.getSelection()


class scrNGEEdit_Components(USXBaseScreen):
    name = 'Components'
    msg = 'Please select components from the list below'
    buttons = ['next_button', 'back_button', 'cancel_button']

    def __init__(self, database, kusuApp=None, gridWidth=45):
        USXBaseScreen.__init__(self, database, kusuApp=kusuApp, gridWidth=gridWidth)

        self.__plugdir = '/opt/kusu/lib/plugins/ngedit'

    def setCallbacks(self):

        #for the buttons
        self.buttonsDict['next_button'].setCallback_(self.doForwardAction)
        self.buttonsDict['back_button'].setCallback_(self.doBackAction)
        self.buttonsDict['cancel_button'].setCallback_(self.doCancelAction)
        self.hotkeysDict['F12'] = self.F12Action

    def F12Action(self):
        return NAV_IGNORE

    def doBackAction(self):
        return NAV_BACK

    def doCancelAction(self):
        return NAV_QUIT

    def doForwardAction(self):
        return NAV_FORWARD

    def drawImpl(self):

        self.screenGrid = snack.Grid(1, 2)

        query = '''SELECT c.kid,k.rname,c.cid,c.cname FROM components c, kits k,
                   repos_have_kits rk, repos r WHERE c.kid = k.kid AND k.kid = rk.kid
                   AND rk.repoid = r.repoid AND r.repoid = %s AND (r.ostype like 
                   concat(c.os,'%%') OR isnull(c.os)) ORDER BY c.kid''' % curNG['repoid']
        self.database.execute(query)
        rv = self.database.fetchall()

        if not rv:
            #no components to display
            self.msg = 'No components were found to match the selected repo'
            self.screenGrid.setField(snack.TextboxReflowed(text=self.msg,
                                     width=self.gridWidth),0,0)
            return

        if curNG.has_key('comps') and curNG['comps'] <> None:
            cidlst = curNG['comps']
        else:
            if not origNG.has_key('comps') or origNG['comps'] == None:
                #first time - get the component list
                query = "select cid from ng_has_comp where ngid = %s" %curNG['ngid']
                self.database.execute(query)
                tplrv = self.database.fetchall()
                origNG['comps'] = [x[0] for x in tplrv]
            cidlst = origNG['comps']

        self.__ct = snack.CheckboxTree(height = 10, scroll = 1)
        curkid = rv[0][0]
        self.__ct.append(rv[0][1])
        i = 0
        for kid,rname,cid,cname in rv:
            if kid <> curkid:
                #new kid encountered - append it
                i += 1
                curkid = kid
                self.__ct.append(rname)
            if cid in cidlst:
                isSel = 1
            else:
                isSel = 0
            self.__ct.addItem(cname,(i,snack.snackArgs['append']), item=cid,selected=isSel)

        self.screenGrid.setField(snack.TextboxReflowed(text=self.msg,width=self.gridWidth),
                                 0,0,growx=1,growy=1)
        self.screenGrid.setField(self.__ct,0,1,(0,1,0,0),growx=1,growy=1,anchorLeft=1)

    def validate(self):
        return True, 'Success'

    def formAction(self):
        curNG['comps'] = [int(x) for x in self.__ct.getSelection()] #convert from long

class scrNGEEdit_Networks(USXBaseScreen):
    name = 'Networks'
    msg = 'Please select the networks from the list below'
    buttons = ['next_button', 'back_button','restore_button', 'cancel_button']

    def __init__(self, database, kusuApp=None, gridWidth=45):
        USXBaseScreen.__init__(self, database, kusuApp=kusuApp, gridWidth=gridWidth)

    def setCallbacks(self):

        #for the buttons
        self.buttonsDict['next_button'].setCallback_(self.doForwardAction)
        self.buttonsDict['back_button'].setCallback_(self.doBackAction)
        self.buttonsDict['restore_button'].setCallback_(self.RestoreAction)
        self.buttonsDict['cancel_button'].setCallback_(self.doCancelAction)
        self.hotkeysDict['F12'] = self.F12Action

    def F12Action(self):
        return NAV_IGNORE

    def RestoreAction(self):
        curNG['nets'] = origNG['nets'][:]
        return NAV_NOTHING

    def doBackAction(self):
        return NAV_BACK

    def doCancelAction(self):
        return NAV_QUIT

    def doForwardAction(self):
        return NAV_FORWARD

    def drawImpl(self):

        if curNG.has_key('nets') and curNG['nets'] <> None:
            netlst = curNG['nets']
        else:
            if not origNG.has_key('nets') or origNG['nets'] == None:
                #first time - get the network list
                query = "select netid from ng_has_net where ngid = %s" %curNG['ngid']
                self.database.execute(query)
                tplrv = self.database.fetchall()
                origNG['nets'] = [x[0] for x in tplrv]
            netlst = origNG['nets']

        cols = [ ['DEVICE','NETWORK','SUBNET','DESCRIPTION'] ]
        self.database.execute('''select max(char_length(device)),max(char_length(network))
                                 , max(char_length(subnet)), max(char_length(netname))
                                 from networks''')

        rv = self.database.fetchone()
        cols.append([int(x) for x in rv]) #justification values
        headstr = '    ' #padding to align with checkboxtree items
        for i in xrange(len(cols[0])): #for all columns
            cols[1][i] = max(cols[1][i], len(cols[0][i]))+1 #make room for the label
            headstr += cols[0][i].ljust(cols[1][i])
        if len(headstr) > MAXWIDTH:
            headstr = headstr[:MAXWIDTH]

        lblheader = snack.Label(headstr)
        self.__ct = snack.CheckboxTree(height = 10, scroll = 1)

        query = "select device, network, subnet, netname, netid from networks"
        self.database.execute(query)
        rv = self.database.fetchall()

        for record in rv:
            record = list(record) #convert to list
            netid = record.pop()
            if netid in netlst:
                isSel = 1
            else:
                isSel = 0
            entrystr = ''
            for i in xrange(len(record)): #construct an entry string
                entrystr += record[i].ljust(cols[1][i])
            if len(entrystr) > MAXWIDTH:
                entrystr = entrystr[:MAXWIDTH - len('...')] + '...'
                
            self.__ct.append(entrystr, item=netid, selected=isSel)

        #render
        self.screenGrid = snack.Grid(1, 2)
        self.screenGrid.setField(lblheader, 0,0, (0,0,0,0), anchorLeft=1)
        self.screenGrid.setField(self.__ct, 0,1, (0,0,0,0), anchorLeft=1)

    def validate(self):
        return True, 'Success'

    def formAction(self):
        ''' Actions taken once the form data was successfully validated.
            Timeline: drawImpl, Next_callback, validation, formAction
        '''
        curNG['nets'] = [int(x) for x in self.__ct.getSelection()] #convert from long


class scrNGEEdit_Packages(USXBaseScreen):
    name = 'Optional Packages'
    msg = 'Please select optional packages to install'
    buttons = ['next_button', 'back_button', 'toggleview_button', 'cancel_button']
    OldRepoId = None
    __ct_alpha = None #checkbox tree of alphabetized packages
    __ct_ctgry = None #checkbox tree of categorized packages

    def __init__(self, database, kusuApp=None, gridWidth=45):
        USXBaseScreen.__init__(self, database, kusuApp=kusuApp, gridWidth=gridWidth)
        self.alphaview = True #alphabetical view by default, categorized view o.w.
        self.__ct = None #pointer to the current checkbox tree structure

    def setCallbacks(self):

        #for the buttons
        self.buttonsDict['next_button'].setCallback_(self.doForwardAction)
        self.buttonsDict['back_button'].setCallback_(self.doBackAction)
        self.buttonsDict['toggleview_button'].setCallback_(self.TogglePackageView)
        self.buttonsDict['cancel_button'].setCallback_(self.doCancelAction)
        self.hotkeysDict['F12'] = self.F12Action
        self.hotkeysDict['F10'] = self.TogglePackageView

    def TogglePackageView(self):
        assert(self.__ct)
        self.alphaview = not self.alphaview
        curNG['packs'] = self.__ct.getSelection()
        time.sleep(0.5) #snack chokes if toggling too fast
        return NAV_NOTHING

    def F12Action(self):
        self.selector.popupMsg('DEBUG', str(self.__ct.getSelection()))
        return NAV_IGNORE

    def doBackAction(self):
        return NAV_BACK

    def doCancelAction(self):
        return NAV_QUIT

    def doForwardAction(self):
        return NAV_FORWARD

    def drawImpl(self):

        self.screenGrid = snack.Grid(1, 1)
        timediff = []

        #rebuild flag logic
        rebuild =  curNG['repoid'] <> self.OldRepoId
        if rebuild:
            self.__ct_alpha = self.__ct_ctgry = self.OldRepoId = None #reset all
        else:
            if self.alphaview and self.__ct_alpha:
                self.__ct = self.__ct_alpha
            elif (not self.alphaview) and self.__ct_ctgry:
                self.__ct = self.__ct_ctgry
            else:
                rebuild = True

        if rebuild:
            self.__ct = snack.CheckboxTree(height = 13, width=MAXWIDTH, scroll = 1)
            query = "select repository,ostype from repos where repoid = %s" %curNG['repoid']
            self.database.execute(query)
            self.__repodir, ostype  = self.database.fetchone()
            self.__repodir = self.__repodir.strip()
    
            if ostype.lower().startswith('fedora'):
                repopackdir = self.__repodir + '/Fedora/RPMS'
                compsfile = glob.glob(self.__repodir + '/repodata/comps*.xml')[0]
            elif ostype.lower().startswith('rhel'):
                repopackdir = self.__repodir + '/Server'
                compsfile = glob.glob(repopackdir + '/repodata/comps*.xml')[0]
            #additional repo os types here
            else:
                raise UnsupportedOSType,"Repo ostype = %s support not yet implemented" % ostype
    
            cwdbackup = os.getcwd()
            os.chdir(repopackdir)
            repopacklst = glob.glob('*.[rR][pP][mM]') #only basenames returned
            repopacklst = [ RpmNameSplit(x)[0] for x in repopacklst ] #get the RPM names
    
            repopackset = Set(repopacklst) #work with the set
    
            #remove packages coming from kits available through the current repo
            rmpacklst = []
            query = '''SELECT k.rname, k.version, k.arch FROM kits k, repos_have_kits rk,
                       repos r WHERE r.repoid = rk.repoid AND rk.kid = k.kid AND
                       k.isOS = 0 AND r.repoid = %s ''' %curNG['repoid']
            self.database.execute(query)
            rv = self.database.fetchall()

            for kitname,kitver,kitarch in rv:
                path = '/depot/kits/%s/%s/%s' % (kitname,kitver,kitarch )
                os.chdir(path)
                kitpacklst = glob.glob('*.[rR][pP][mM]')
                kitpacklst = [ RpmNameSplit(x)[0] for x in kitpacklst ]
                rmpacklst.extend(kitpacklst)
    
            repopackset -= Set(rmpacklst)
            os.chdir(cwdbackup)
            #repopackset ready
    
            if self.alphaview: #alphabetic view

                curletter = None
                i = -1
                for p in sorted(repopackset):
                    letter = p[0]
                    if letter != curletter:
                        self.__ct.append(letter)
                        i += 1
                        curletter = letter
                    self.__ct.addItem(p,(i,snack.snackArgs['append']), item=p)

                self.__ct_alpha = self.__ct
                self.OldRepoId = curNG['repoid']

            else: #category view
                import yum.comps
                from kusu.kitops.package import PackageFactory

                prog_dlg = self.selector.popupProgress('Categorized view', 'Generating categorized view ...')

                t1 = time.time()
                #instantiate comps
                compsinst = yum.comps.Comps()
                compsinst.add(compsfile)

                tmpcnt = 0
                ci = 0 #category index
                for c in compsinst.categories:
                    self.__ct.append(c.name, item=c.categoryid)
                    gi = 0
                    for g in sorted(c.groups):
                        ginst = compsinst.return_group(g)
                        set2show = None
                        if ginst: #some groups don't have any packages
                            set2show = repopackset & Set(ginst.packages)
                        if set2show:  # do we have a non-empty intersection?
                            self.__ct.addItem(g, path=(ci,-1), item=ginst.groupid)
                            for p in sorted(set2show):
                                tmpcnt+=1
                                self.__ct.addItem(p, path=(ci,gi,-1), item=p)
                            #done package
                            repopackset -= set2show
                            gi += 1
                    #done group
                    ci += 1
                #done category

                t2 = time.time()
        
                #construct group dictionary for remaining packages
                groupdict = {}
                self.__ct.append("Other")
                for p in repopackset:
                    #reconstruct the full package name to pass to PackageFactory
                    tmplst = glob.glob("%s/%s-[0-9]*" % (repopackdir, p))
                    if not tmplst: #corner case
                        tmplst = glob.glob("%s/%s-*.rpm" % (repopackdir, p))
                    pfile = tmplst[0]
                    #get group through my package library -> RPMTAG_GROUP
                    pinst = PackageFactory(pfile)
                    group = pinst.getGroup()
                    if group not in groupdict.keys():
                        groupdict[group] = [] #initialize
                    groupdict[group].append(p)
               
                t3 = time.time()
 
                # display remaining packages
                tmpcnt2 = 0
                gi = 0
                for g in sorted(groupdict):
                    self.__ct.addItem(g,path=(ci,-1), item=g)
                    for p in sorted(groupdict[g]):
                        tmpcnt2 += 1
                        self.__ct.addItem(p, path=(ci,gi,-1), item = p)
                    gi += 1
                #done remaining packages

                t4 = time.time()
                prog_dlg.close()

                kl.debug("Optional Packages: comps: %d, unlisted: %d;\ntcomps=%f;\t" %(tmpcnt, tmpcnt2,t2-t1) +\
                   "time to build d.s. for other=%f;\ttime to add other = %f" %(t3-t2,t4-t3))

                self.__ct_ctgry = self.__ct
                self.OldRepoId = curNG['repoid']

        
        #mark currently selected packages
        s1 = Set(self.__ct.getSelection())
        curpacklst = [] #require selection
        if curNG['packs']:
            curpacklst = curNG['packs']
        s2 = Set(curpacklst)

        for p in s1-s2:
            self.__ct.setEntryValue(item=p, selected=0)

        #note: the user may have changed the repo, hence some packages in
        #curNG['packs'] (a.k.a s2) may not be in the currently selected repo
        for p in s2-s1:
            try:
                self.__ct.setEntryValue(item=p, selected=1)
            except KeyError,msg:
                continue

        #at this point self.__ct is ready to be displayed
        self.screenGrid.setField(self.__ct,0,0,(0,0,0,0),growx=1,growy=1,anchorLeft=1)

    def validate(self):
        return True, 'Success'

    def formAction(self):
        curNG['packs'] = self.__ct.getSelection()

        ###TODO: use modules screen only if diskless
        #if curNG['installtype'] and curNG['installtype'].lower() <> 'package':
        #    if not isinstance(self.selector.screens[self.selector.currentStep+1], scrNGEEdit_General):
        #        self.selector.screens.insert(self.selector.currentStep+1,\
        #                    scrNGEEdit_General(database=self.database, kusuApp=self.kusuApp))
        #self.selector.popupMsg('DEBUG', str(self.selector.screens))


class scrNGEEdit_Modules(USXBaseScreen):
    name = 'Modules'
    buttons = ['next_button', 'back_button', 'cancel_button']

    def __init__(self, database, kusuApp=None, gridWidth=45):
        USXBaseScreen.__init__(self, database, kusuApp=kusuApp, gridWidth=gridWidth)

    def setCallbacks(self):

        #for the buttons
        self.buttonsDict['next_button'].setCallback_(self.doForwardAction)
        self.buttonsDict['back_button'].setCallback_(self.doBackAction)
        self.buttonsDict['cancel_button'].setCallback_(self.doCancelAction)
        self.hotkeysDict['F12'] = self.F12Action

    def F12Action(self):
        self.selector.popupMsg('DEBUG', str(self.__ct.getSelection()))
        return NAV_IGNORE

    def doBackAction(self):
        return NAV_BACK

    def doCancelAction(self):
        return NAV_QUIT

    def doForwardAction(self):
        return NAV_FORWARD

    def drawImpl(self):
        self.screenGrid = snack.Grid(1, 1)
        self.__ct = snack.CheckboxTree(height = 13, width=MAXWIDTH, scroll = 1)

        if not curNG['comps']:
            #no components chosen for this nodegroup
            msg = 'No components associated with this nodegroup. No modules to display.'
            self.screenGrid.setField(snack.TextboxReflowed(text=msg,width=self.gridWidth),
                                 0,0,growx=1,growy=1)
            return
        
        assert(len(curNG['comps']))

        #get repository information
        query = "select repository,ostype from repos where repoid = %s" %curNG['repoid']
        self.database.execute(query)
        self.__repodir, ostype  = self.database.fetchone()
        self.__repodir = self.__repodir.strip()

        if ostype.lower().startswith('fedora'):
            repopackdir = self.__repodir + '/Fedora/RPMS'
        elif ostype.lower().startswith('rhel'):
            repopackdir = self.__repodir + '/Server'
        #additional repo os types here
        else:
            raise UnsupportedOSType,"Repo ostype = %s support not yet implemented" % ostype

        assert(repopackdir)

        #2. obtain the name of driverpacks to examine
        query = "SELECT dpname from driverpacks where cid in " + seq2tplstr(curNG['comps'])
        self.database.execute(query)
        rv = self.database.fetchall()
        dpacklst = [ x for x, in rv]
        # create a temp dir for ko files
        tmpdir = tempfile.mkdtemp()

        prog_dlg = self.selector.popupProgress('Driver Package Extraction', 'Generating module list...')

        t1 = time.time()
        for dpack in dpacklst:
            dpackfull = "%s/%s" %(repopackdir,dpack)
            if not os.path.exists(dpackfull):
                self.selector.popupMsg('WARNING', 'Driver package %s not found in repo %s'\
                                        %(dpack,self.__repodir))
            else:
                #3. extract the driverpack's ko files (can't use rpmtool.extract)
                cmd = "rpm2cpio %s | cpio -id *.ko" %dpackfull
                p = subprocess.Popen(   cmd, shell=True, 
                                        cwd = tmpdir,
                                        stdout = subprocess.PIPE,
                                        stderr = subprocess.PIPE
                                     )
                p.communicate()

        t2 = time.time()

        #4. populate the module dictionary with description
        moddict = {}    #dictionary of modules & their description
        cmd = 'find %s -name "*.ko" | xargs modinfo | egrep "^filename|^description"'  %tmpdir
        p = subprocess.Popen(cmd, shell=True, cwd = tmpdir,
                                     stdout = subprocess.PIPE,
                                     stderr = subprocess.PIPE
                             )
        rv = p.communicate()[0]
        fname = None
        for line in rv.split('\n'):
            if line.startswith('filename:'):
                fname = line.split(':',1)[1].strip() #path/file.ext
                fname = os.path.splitext(os.path.split(fname)[1])[0]
                moddict[fname] = ''
            elif line.startswith('description:'):
                if not moddict[fname]: #only one description - posible >1 desc field per module
                    moddict[fname] = line.split(':',1)[1].strip()

        t3 = time.time()
        prog_dlg.close()
        shutil.rmtree(tmpdir)
        kl.debug("Modules screen: \ndriver rpm extraction: %f\ndesc info extraction: %f\nmoddict len = %d" \
                    %(t2-t1,t3-t2, len(moddict))
                )
        #self.selector.popupMsg('DEBUG', 'driver rpm extraction: %f\ndesc info extraction: %f\nmoddict len = %d' %(t2-t1,t3-t2, len(moddict)))

        curletter = None
        i = -1
        for m in sorted(moddict):
            letter = m[0]
            if letter != curletter:
                maxlen = max(map(len, filter(lambda x : x[0] == letter, moddict.keys())))
                self.__ct.append(letter)
                i += 1
                curletter = letter
            str2add = (m.ljust(maxlen+1) + moddict[m])[:MAXWIDTH]
            isSel = 0
            if m in curNG['modules']:
                isSel = 1
            self.__ct.addItem(str2add,(i,snack.snackArgs['append']), item=m, selected=isSel)

        self.screenGrid.setField(self.__ct,0,0,(0,0,0,0),growx=1,growy=1,anchorLeft=1)


    def validate(self):
        return True, 'Success'

    def formAction(self):
        curNG['modules'] = self.__ct.getSelection()
        kl.debug("MODULES Selected: %s" %str(curNG['modules']))
        #self.selector.popupMsg('selected modules', str(curNG['modules']))

class scrNGEEdit_PartSchema(USXBaseScreen):
    name = 'Partition Schema'
    buttons = [ 'next_button', 'back_button', 'new_button','edit_button', 
                'delete_button', 'cancel_button'
              ]

    def __init__(self, database, kusuApp=None, gridWidth=45):
        USXBaseScreen.__init__(self, database, kusuApp=kusuApp, gridWidth=gridWidth)
        self.PartSchema = None


    def setCallbacks(self):

        #for the buttons
        self.buttonsDict['next_button'].setCallback_(self.doForwardAction)
        self.buttonsDict['back_button'].setCallback_(self.doBackAction)
        self.buttonsDict['cancel_button'].setCallback_(self.doCancelAction)
        self.buttonsDict['new_button'].setCallback_(self.doNewAction)
        self.buttonsDict['edit_button'].setCallback_(self.doEditAction)
        self.buttonsDict['delete_button'].setCallback_(self.doDeleteAction)
        self.hotkeysDict['F12'] = self.F12Action

    def F12Action(self):
        id = self.listbox.current()
        if id != None:
            partrec = self.PartSchema.getPartRecByPK(id)
            dct = self.PartSchema.pk2dict[id]
            self.selector.popupMsg('DEBUG', 'currently pointing to id = %s\npartrec=%s\ndict=%s'\
                                    %(id,str(partrec),str(dct)))
        return NAV_IGNORE

    def doNewAction(self):
        button,item = self.selector.popupListBox('Select type of device', "Please select what you'd like to create",\
                 [('Partition', 'partition'), ('Logical Volume', 'log_vol'), ('Volume Group', 'vol_grp')])

        if button != 'cancel':
            if item == 'partition':
                ScreenFactory.screens = [
                    scrPartSchema_PartEdit(self.PartSchema,id=None,database=self.database, kusuApp=self.kusuApp)
                                        ]
                ks = USXNavigator(screenFactory=ScreenFactory, screenTitle="Partition Schema Modification", showTrail=False)
                ks.run()
            elif item == 'log_vol':
                ScreenFactory.screens = [
                    scrPartSchema_LVEdit(self.PartSchema,id=None,database=self.database, kusuApp=self.kusuApp)
                                        ]
                ks = USXNavigator(screenFactory=ScreenFactory, screenTitle="Partition Schema Modification", showTrail=False)
                ks.run()

            elif item == "vol_grp":
                ScreenFactory.screens = [
                    scrPartSchema_VGEdit(self.PartSchema,id=None,database=self.database, kusuApp=self.kusuApp)
                                        ]
                ks = USXNavigator(screenFactory=ScreenFactory, screenTitle="Partition Schema Modification", showTrail=False)
                ks.run()


        return NAV_NOTHING

    def doEditAction(self):
        id = self.listbox.current()
        if self.PartSchema.isPartition(id):
            ScreenFactory.screens = [
               scrPartSchema_PartEdit(self.PartSchema,id=id,database=self.database, kusuApp=self.kusuApp)
                                    ]
            ks = USXNavigator(screenFactory=ScreenFactory, screenTitle="Partition Schema Modification", showTrail=False)
            ks.run()


        elif self.PartSchema.isLV(id):
            ScreenFactory.screens = [
               scrPartSchema_LVEdit(self.PartSchema,id=id,database=self.database, kusuApp=self.kusuApp)
                                    ]
            ks = USXNavigator(screenFactory=ScreenFactory, screenTitle="Partition Schema Modification", showTrail=False)
            ks.run()

        elif self.PartSchema.isVG(id):
            ScreenFactory.screens = [
               scrPartSchema_VGEdit(self.PartSchema,id=id,database=self.database, kusuApp=self.kusuApp)
                                    ]
            ks = USXNavigator(screenFactory=ScreenFactory, screenTitle="Partition Schema Modification", showTrail=False)
            ks.run()

        else:
            self.selector.popupMsg('Error', 'Modification allowed for partitions, VGs, & LVs only')

        return NAV_NOTHING

    def doDeleteAction(self):
        id = self.listbox.current()
        if not id:
            self.selector.popupMsg('Delete Operation', 'Currently selected item is not deletable')
            return NAV_NOTHING

        selected_dict = self.PartSchema.pk2dict[id]
        if self.PartSchema.isPartition(id):
            if selected_dict['fs'] == 'physical volume':
                partrec = self.PartSchema.getPartRecByPK(id)
                (ispv, vg) = translatePartitionOptions(partrec['options'],'pv')
                if vg in self.PartSchema.schema['vg_dict'].keys():
                    #can't delete PV if any VGs are using it
                    self.selector.popupMsg("Delete Operation", "Can't delete a PV if it has VGs using it")
                    return NAV_NOTHING

        if self.PartSchema.isVG(id):
            #disallow deletion if LVs associated with this VG exist
            if  selected_dict['lv_dict'].keys():
                self.selector.popupMsg("Delete Operation", "Cannot delete a non-empty " +\
                                       "Volume group. Delete the logical volumes first.")
                return NAV_NOTHING

            #disassociate the volume group from all physical volumes
            for disk_key in self.PartSchema.schema['disk_dict']:
                for part_key in self.PartSchema.schema['disk_dict'][disk_key]['partition_dict']:
                    part_dict = self.PartSchema.schema['disk_dict'][disk_key]['partition_dict'][part_key]
                    partrec = self.PartSchema.getPartRecByPK(part_dict['instid'])
                    assert(partrec)
                    #disassociate this PV
                    (ispv, vg) = translatePartitionOptions(partrec['options'],'pv')
                    if ispv and vg == selected_dict['name']:
                        optlst = partrec['options'].split(';')
                        #optlst = [ ifelse(x.strip().lower().startswith('vg='), 'vg=', x ) for x in optlst ]
                        optlst = [x for x in optlst if not x.strip().lower().startswith('vg=')]
                        partrec['options'] = string.join(optlst, ';')
                        

        for i in xrange(len(self.PartSchema.PartRecList)):
            p = self.PartSchema.PartRecList[i]
            if p.PKval == id:
                del self.PartSchema.PartRecList[i]
                break

        return NAV_NOTHING

    def doBackAction(self):
        return NAV_BACK

    def doCancelAction(self):
        return NAV_QUIT

    def doForwardAction(self):
        return NAV_FORWARD


    def drawImpl(self):

        if not self.PartSchema:
            self.PartSchema = PartSchema() #triggers disk_profile creation
            schema = self.PartSchema.mycreateSchema(curNG['parts'])
        else:
            schema = self.PartSchema.mycreateSchema()

        self.screenGrid = snack.Grid(1, 1)

        self.listbox = kusuwidgets.ColumnListbox(height=8,
                                 colWidths=[15,15,15,15],
                                 colLabels=['Device', 'Size(MB) ', 'Type  ',
                                            'Mount Point   '],
                                 justification=[LEFT, RIGHT, LEFT, LEFT], 
                                 returnExit=0)


        #str2display = ''
        #for d in schema.keys():
        #    if type(schema[d]) == type({}):
        #        str2display += d.upper()+'\n'
        #        for k in schema[d].keys():
        #            if type(schema[d][k]) == type({}):
        #                str2display += "\t%s\n" %str(k).upper()
        #                for k2 in schema[d][k].keys():
        #                    str2display += "\t\t%s : %s\n" % (k2, schema[d][k][k2])
        #            else:
        #                str2display += "\t%s : %s\n" %(k, schema[d][k])
        #    else:
        #        str2display += '%s : %s\n' %(d.upper(), schema[d])
        #self.selector.popupMsg("DEBUG", str2display, width = MAXWIDTH )

        # retrieve info about logical volumes and lv groups
        lvg_keys = schema['vg_dict'].keys()

        for key in sorted(lvg_keys):
            lvg = schema['vg_dict'][key] 
            lvg_displayname = 'VG ' + key
            lvg_size_MB = ''
            # display volume groups first in listbox
            self.listbox.addRow(['VG ' + key,  str(lvg_size_MB), 'VolGroup',
                                 ''], objRef=lvg['instid'])

            lv_keys = lvg['lv_dict'].keys()
            for lv_key in sorted(lv_keys):
                lv =  lvg['lv_dict'][lv_key] 
                lv_devicename = '  LV ' + lv_key
                lv_size_MB = lv['size_MB']   
                # display indented logical volumes belonging to the vg.
                self.listbox.addRow([lv_devicename, str(lv_size_MB),lv['fs'],
                                    lv['mountpoint']], objRef=lv['instid'])


        disk_keys = schema['disk_dict'].keys()
        for key in sorted(disk_keys):
            # display device
            device = schema['disk_dict'][key]
            self.listbox.addRow(['Disk '+str(key),  '', '', ''] ) 
            parts_dict =  device['partition_dict']          
            parts_keys = parts_dict.keys()
            for part_key in sorted(parts_keys):
                partition = parts_dict[part_key]
                part_devicename = '  ' +'d'+ str(key) +'p'+ str(part_key)
                # indent one more level if logical partition.
                #if partition.part_type == 'logical': part_devicename = '  ' + part_devicename
                fs_type = partition['fs']
                mountpoint = partition['mountpoint']
                if fs_type == 'physical volume':
                    partrec = self.PartSchema.getPartRecByPK(partition['instid'])
                    (ispv,vg) = translatePartitionOptions(partrec['options'],'pv')
                    if ispv and vg:
                        mountpoint = vg
                # display partition info
                self.listbox.addRow([part_devicename,
                                    str(partition['size_MB']),
                                    fs_type,
                                    #mountpoint], partition['instid'])
                                    mountpoint], partition['instid'])


        if self.listbox.length < 1:
            msg = 'no partition schema associated with the current Node Group'
            self.screenGrid.setField(snack.TextboxReflowed(width=MAXWIDTH, maxHeight=10, 
                text=msg), 0,0, (0,0,0,0), anchorLeft=1)
        else:
            self.screenGrid.setField(self.listbox, col=0, row=0, anchorLeft=1,
                                 padding=(0,0,0,0))


    def validate(self):
        return True, 'Success'

    def formAction(self):
        curNG['parts'] = self.PartSchema.PartRecList
        #self.selector.popupMsg('partition schema', "%s\n%s" %(str(curNG['parts']), str(curNG == origNG)))
        #self.selector.popupMsg('original part schema', 'origNG[parts]= %s' %str(origNG['parts']))

class scrPartSchema_PartEdit(USXBaseScreen):
    ''' This screen class allows to edit existing or create new Partitions. 
        It exposes PartSchemaObj to the user for modification.
    '''
    name = "Partition Modification"
    buttons = [ 'ok_button', 'cancel_button' ]

    def __init__(self, PartSchemaObj, id=None,  database=None, kusuApp=None,gridWidth=45):
        USXBaseScreen.__init__(self, database, kusuApp=kusuApp, gridWidth=gridWidth)
        self.PartSchemaObj = PartSchemaObj  #passed by ref.
        self.partition = PartSchemaObj.getDictByPK(id)
        self.PartRec = PartSchemaObj.getPartRecByPK(id)
        self.disk_key = None
        self.part_key = None
        schema = PartSchemaObj.schema
        if id != None:
            #we're editing - get the disk_key we belong to
            done = False
            for disk_key in schema['disk_dict']:
                for part_key in schema['disk_dict'][disk_key]['partition_dict']:
                    part_dict = schema['disk_dict'][disk_key]['partition_dict'][part_key]
                    if part_dict['instid'] == id:
                        self.disk_key = disk_key
                        self.part_key = part_key
                        assert(self.partition == part_dict)
                        done = True
                        break
                if done:
                    break

    def setCallbacks(self):
        self.buttonsDict['ok_button'].setCallback_(self.doOkAction)
        self.buttonsDict['cancel_button'].setCallback_(self.doCancelAction)

    def doOkAction(self):
        #perform preparation required for validation and subsequent formAction
        return NAV_FORWARD

    def doCancelAction(self):
        return NAV_QUIT

    def drawImpl(self):
        self.screenGrid = snack.Grid(1, 5)

        #mntpnt
        self.mountpoint = kusuwidgets.LabelledEntry('Mount Point:', 20,
                                                    text="", hidden=0,
                                                    password=0, scroll=0,
                                                    returnExit=0
                                                   )
        if self.partition and self.partition['mountpoint']:
            self.mountpoint.setEntry(self.partition['mountpoint'])

        #fs
        self.filesystem = kusuwidgets.ColumnListbox(2, colWidths=[20], 
                                                    colLabels=['File System type:'],
                                                    justification=[LEFT],
                                                    returnExit=0)

        fs_types = self.PartSchemaObj.disk_profile.fsType_dict.keys()
        fs_types.sort()
        for fs in fs_types:
            self.filesystem.addRow([fs], fs)
        if self.partition and self.partition['fs'] and self.partition['fs'] in fs_types:
            self.filesystem.setCurrent(self.partition['fs'])

        #disks
        self.drives = kusuwidgets.ColumnListbox(2, colWidths=[20],
                                                colLabels=['Allowable Drives:'],
                                                justification=[LEFT],
                                                returnExit=0)

        disks = self.PartSchemaObj.schema['disk_dict'].keys()
        disks = ['Disk %s' %x for x in disks]
        for disk in disks:
            self.drives.addRow([disk], disk)
        if self.disk_key:
            self.drives.setCurrent('Disk %s' %self.disk_key)

        #size
        fill = False
        size = ''
        if self.partition:
            fill = self.partition['fill']
            size = str(self.partition['size_MB'])
            
        self.fixed_size = snack.SingleRadioButton('Fixed Size (MB):', None,
                                                  isOn=not fill)
        self.fixed_size_entry = snack.Entry(7)

        self.min_size = snack.SingleRadioButton('Fill at least (MB):',
                                                self.fixed_size, isOn = fill)
        self.min_size_entry = snack.Entry(7)
        if fill:
            self.min_size_entry.set(size)
        else:
            self.fixed_size_entry.set(size)

        #preserve
        isOn = 0
        if self.partition and self.partition['preserve'] == 1:
            isOn = 1
        self.do_not_format_partition = snack.Checkbox('Do not format partition', isOn = isOn)
                

        # position widgets on screen

        self.screenGrid.setField(self.mountpoint, 0,0, padding=(0,0,0,1))
        subgrid = snack.Grid(2,1)

        subgrid.setField(self.filesystem, 0,0, padding=(0,0,2,0))
        subgrid.setField(self.drives, 1,0, padding=(2,0,0,0))
        self.screenGrid.setField(subgrid, 0,1)

        subgrid = snack.Grid(2,1)
        subgrid.setField(self.fixed_size, 0,0)
        subgrid.setField(self.fixed_size_entry, 1,0)
        self.screenGrid.setField(subgrid, 0,2, anchorLeft=1, padding=(0,1,0,0))

        subgrid = snack.Grid(2,1)
        subgrid.setField(self.min_size, 0,0)
        subgrid.setField(self.min_size_entry, 1,0)
        self.screenGrid.setField(subgrid, 0,3, anchorLeft=1)

        self.screenGrid.setField(self.do_not_format_partition, 0,4, padding=(0,1,0,1))
        

    def validate(self):
        """Validation code goes here. Activated when 'Next' button is pressed."""
        fs = self.filesystem.current()
        if fs == "physical volume":
            if self.mountpoint.value().strip():
                return False, "Physical Volumes cannot have a mount point"
        elif fs in ('ext2', 'ext3'):
            if not self.mountpoint.value().strip():
                return False, "Regular partitions require a mountpoint"

        #size validation
        if self.min_size.selected():
            size = self.min_size_entry.value()
        elif self.fixed_size.selected():
            size = self.fixed_size_entry.value()
        size = size.strip()
        if not size:
            return False, "Please specify the partition size"
        try:
            size = int(size)
            if size <= 0:
                return False, "Partition size must be a positive integer"
        except:
            return False, "Partition size must be a positive integer"
        
        return True, 'Success'

    def formAction(self):
        ''' Actions taken once the form data was successfully validated.
            Timeline: Next_callback, validation, formAction
        '''
        #collect widget data into a PartitionRec object
        if self.partition:
            id = self.partition['instid']
        else:
            id = self.PartSchemaObj.getNewPartId()
        partrec = PartitionRec(idpartitions = id)

        #mntpnt
        partrec['mntpnt'] = self.mountpoint.value().strip()
        #fs
        fs = self.filesystem.current()
        partrec['fstype'] = fs

        #options
        optlst = []
        if fs == 'physical volume':
            optlst.append('pv')
            if self.partition and self.PartRec:
                ispv,vgname = translatePartitionOptions(self.PartRec['options'], 'pv')
                if ispv and vgname:
                    optlst.append('vg=%s' %vgname)
        if self.min_size.selected():
            optlst.append('fill')
        optlst.sort()
        partrec['options'] = string.join(optlst,';')

        #preserve
        preserve = 0
        if self.do_not_format_partition.value():
            preserve = 1
        partrec['preserve'] = preserve

        #size
        size = None
        if self.min_size.selected():
            size = self.min_size_entry.value()
        elif self.fixed_size.selected():
            size = self.fixed_size_entry.value()
        partrec['size'] = size

        #device/partition
        DevPartNumDone = False
        if fs == 'physical volume':
            if self.partition: #editing
                if self.PartRec['device'].lower() == 'n':
                    #editing spanning PV
                    device = 'N'
                    partition = 0
                    DevPartNumDone = True
            else:       #new PV creation
                #determine whether to have this PV span all disks
                pvmap = self.PartSchemaObj.getPVMap()
                DevPartNumDone = True
                for k in pvmap.keys():
                    p = self.PartSchemaObj.getPartRecByPK(k)
                    if p['device'] == 'N':
                        #spanning PV already exists
                        DevPartNumDone = False
                        break
                if DevPartNumDone == True:
                    #no spanning PVs yet
                    msg = 'Do you want this PV to span all disks?'
                    pv_span = self.selector.popupYesNo('Spanning PV', msg, defaultNo=True)
                    if pv_span:
                        device = 'N'
                        partnum = 0
                    else:
                        DevPartNumDone = False

        if not DevPartNumDone:
            device = int(self.drives.current().split()[1].strip())
            if self.partition and device == self.disk_key:
                partnum = self.part_key     #preserve partition number
            else:
                #new disk or new partition
                disk_dict = self.PartSchemaObj.schema['disk_dict'][device]
                part_keys = disk_dict['partition_dict'].keys()
                part_keys = [ k for k in part_keys if not disk_dict['partition_dict'][k].has_key('pv_span') ]
                if not part_keys:
                    partnum = 1
                else:
                    partnum = max(part_keys) + 1
        partrec['device'] = str(device)
        partrec['partition'] = str(partnum)

        kl.debug("scrPartSchema_PartEdit: \npartrec = %s\nvg_dict = %s\ndisk_dict = %s" \
            %(str(partrec),str(self.PartSchemaObj.schema['vg_dict']), str(self.PartSchemaObj.schema['disk_dict']))
                )
        #self.selector.popupMsg('DEBUG', 'partrec = %s\nvg_dict = %s\ndisk_dict = %s' \
        #        %(str(partrec),str(self.PartSchemaObj.schema['vg_dict']), str(self.PartSchemaObj.schema['disk_dict'])))
        
        if self.partition: #we're editing
            self.PartSchemaObj.updatePartRec(partrec)
        else:   #new partition
            self.PartSchemaObj.addPartRec(partrec)

class scrPartSchema_LVEdit(USXBaseScreen):
    ''' This screen class allows to edit existing or create new Logical Volumes. 
        It exposes PartSchemaObj to the user for modification.
    '''
    name = "Logical Volume Modification"
    buttons = [ 'ok_button', 'cancel_button' ]

    def __init__(self, PartSchemaObj, id=None,  database=None, kusuApp=None,gridWidth=45):
        USXBaseScreen.__init__(self, database, kusuApp=kusuApp, gridWidth=gridWidth)
        self.PartSchemaObj = PartSchemaObj  #passed by ref.
        self.partition = PartSchemaObj.getDictByPK(id)
        self.vg_name = None
        self.lv_name = None
        schema = PartSchemaObj.schema
        if id != None:
            #we're editing - get the vgname we belong to
            done = False
            for vg in schema['vg_dict']:
                for lvname in schema['vg_dict'][vg]['lv_dict']:
                    lv_dict = schema['vg_dict'][vg]['lv_dict'][lvname]
                    if lv_dict['instid'] == id:
                        self.vg_name = vg
                        self.lv_name = lvname
                        assert(self.partition == lv_dict)
                        done = True
                        break
                if done:
                    break

    def setCallbacks(self):
        self.buttonsDict['ok_button'].setCallback_(self.doOkAction)
        self.buttonsDict['cancel_button'].setCallback_(self.doCancelAction)

    def doOkAction(self):
        #perform preparation required for validation and subsequent formAction
        return NAV_FORWARD

    def doCancelAction(self):
        return NAV_QUIT

    def drawImpl(self):
        self.screenGrid = snack.Grid(1, 5)
        lbllst = ['Mount Point:', 'Logical Volume Name:', 'Size (MB):']
        justval = max([len(x) for x in lbllst])

        #mntpnt
        self.mountpoint = kusuwidgets.LabelledEntry(lbllst[0].rjust(justval), 20,
                                                    text="", hidden=0,
                                                    password=0, scroll=0,
                                                    returnExit=0
                                                   )
        if self.partition and self.partition['mountpoint']:
            self.mountpoint.setEntry(self.partition['mountpoint'])

        #lvname
        self.lvname = kusuwidgets.LabelledEntry(
                                        lbllst[1].rjust(justval),
                                        20, text="", hidden=0, password=0,
                                        scroll=0, returnExit=0
                                   )
        if self.partition:
            if self.lv_name:
                self.lvname.setEntry(self.lv_name)
            self.lvname.setEnabled(False)


        self.size = kusuwidgets.LabelledEntry(lbllst[2].rjust(justval), 20,
                                              text="", hidden=0, password=0,
                                              scroll=0, returnExit=0
                                             )
        if self.partition:
            self.size.setEntry(str(self.partition['size_MB']))

        self.filesystem = kusuwidgets.ColumnListbox(2, colWidths=[20], 
                                                colLabels=['File System type:'],
                                                justification=[LEFT],
                                                returnExit=0)
        fs_types = self.PartSchemaObj.disk_profile.fsType_dict.keys()
        fs_types.sort()
        for fs in fs_types:
            self.filesystem.addRow([fs], fs)
        if self.partition and self.partition['fs'] and self.partition['fs'] in fs_types:
            self.filesystem.setCurrent(self.partition['fs'])


        self.volumegroup = kusuwidgets.ColumnListbox(2, colWidths=[20],
                                                    colLabels=['Volume Group:'],
                                                    justification=[LEFT])

        for vg_key in self.PartSchemaObj.schema['vg_dict']:
            self.volumegroup.addRow([vg_key],vg_key)
        if self.partition and self.vg_name:
            self.volumegroup.setCurrent(self.vg_name)

        #preserve
        isOn = 0
        if self.partition and self.partition['preserve'] == 1:
            isOn = 1

        self.do_not_format_partition = snack.Checkbox('Do not format partition',isOn=isOn)

        #position widgets on the screen
        self.screenGrid.setField(self.mountpoint, 0,0)
        self.screenGrid.setField(self.lvname, 0,1)
        self.screenGrid.setField(self.size, 0,2)

        subgrid = snack.Grid(2,1)
        subgrid.setField(self.filesystem, 0,0, padding=(0,0,2,0))
        subgrid.setField(self.volumegroup, 1,0, padding=(2,0,0,0))
        self.screenGrid.setField(subgrid, 0,3, padding=(0,1,0,1))

        self.screenGrid.setField(self.do_not_format_partition, 0,4, padding=(0,0,0,1))


    def validate(self):
        mntpnt = self.mountpoint.value().strip()
        fs = self.filesystem.current()
        if fs in ('ext2','ext3') and not mntpnt:
            return False, "Logical volumes of specified type require a mountpoint"

        #size validation
        size = self.size.value().strip()
        if not size:
            return False, "Please specify the logical volume size"
        try:
            size = int(size)
            if size <= 0:
                return False, "LV size must be a positive integer"
        except:
            return False, "LV size must be a positive integer"

        return True, 'Success'

    def formAction(self):
        #collect widget data into a PartitionRec object
        if self.partition:
            id = self.partition['instid']
        else:
            id = self.PartSchemaObj.getNewPartId()
        partrec = PartitionRec(idpartitions = id)

        #mntpnt
        partrec['mntpnt'] = self.mountpoint.value().strip()
        #fs
        fs = self.filesystem.current()
        partrec['fstype'] = fs

        #options
        optlst = ['lv']
        optlst.append('vg=%s' %self.volumegroup.current())
        if self.partition and self.partition['fill']:
            optlst.append('fill')
        partrec['options'] = string.join(optlst,';')

        #preserve
        preserve = 0
        if self.do_not_format_partition.value():
            preserve = 1
        partrec['preserve'] = preserve

        partrec['size'] = self.size.value().strip()
        partrec['device'] = self.lvname.value().strip()

        if self.partition: #we're editing
            self.PartSchemaObj.updatePartRec(partrec)
        else:   #new partition
            self.PartSchemaObj.addPartRec(partrec)

class scrPartSchema_VGEdit(USXBaseScreen):
    ''' This screen class allows to edit existing or create new Volume Groups. 
        It exposes PartSchemaObj to the user for modification.
    '''
    name = "Logical Volume Modification"
    buttons = [ 'ok_button', 'cancel_button' ]

    def __init__(self, PartSchemaObj, id=None,  database=None, kusuApp=None,gridWidth=45):
        USXBaseScreen.__init__(self, database, kusuApp=kusuApp, gridWidth=gridWidth)
        self.PartSchemaObj = PartSchemaObj  #passed by ref.
        self.partition = PartSchemaObj.getDictByPK(id)
        self.PartRec = PartSchemaObj.getPartRecByPK(id)

    def setCallbacks(self):
        self.buttonsDict['ok_button'].setCallback_(self.doOkAction)
        self.buttonsDict['cancel_button'].setCallback_(self.doCancelAction)

    def doOkAction(self):
        #perform preparation required for validation and subsequent formAction
        return NAV_FORWARD

    def doCancelAction(self):
        return NAV_QUIT

    def drawImpl(self):
        self.screenGrid = snack.Grid(1, 4)
        lbllst = ['Volume Group Name:', 'Physical Extent (MB):']
        justval = max([len(x) for x in lbllst])


        self.vg_name = kusuwidgets.LabelledEntry(
                                       lbllst[0].rjust(justval),
                                       21, text="", hidden=0, password=0,
                                       scroll=0, returnExit=0
                                   )
        if self.partition:
            self.vg_name.setEnabled(False)
            self.vg_name.setEntry(self.partition['name'])

        self.phys_extent = kusuwidgets.LabelledEntry(
                                           lbllst[1].rjust(justval),
                                           21, text="32", hidden=0, password=0,
                                           scroll=0, returnExit=0
                                       )
        if self.partition:
            self.phys_extent.setEnabled(False)
            self.phys_extent.setEntry(self.partition['extent_size'].split('M',1)[0])

        self.phys_to_use_lbl = snack.Label('Physical Volumes to Use:')
        self.phys_to_use = snack.CheckboxTree(height=3, scroll=1)

        #populate with available PVs
        PVidmap = self.PartSchemaObj.getPVMap()
        for k,v in PVidmap.items():
            if self.partition and v and v != self.partition['name']:
                #this pv is associated with another VolGrp
                continue
            isOn = False
            if self.partition and v and v == self.partition['name']:
                isOn = True
            #determine the disk & partition to display
            for disk_key in self.PartSchemaObj.schema['disk_dict']:
                part_dict = self.PartSchemaObj.schema['disk_dict'][disk_key]['partition_dict']
                for part_key in part_dict.keys():
                    partition = part_dict[part_key]
                    if partition['instid'] == k:
                        self.phys_to_use.append("d%sp%s" %(disk_key,part_key), item=k, selected=isOn)
                    

        #position widgets on the screen
        self.screenGrid.setField(self.vg_name, 0,0)
        self.screenGrid.setField(self.phys_extent, 0,1)
        self.screenGrid.setField(self.phys_to_use_lbl, 0,2)
        self.screenGrid.setField(self.phys_to_use, 0,3)

    def validate(self):
        #ensure uniqueness of VG name
        vgname = self.vg_name.value().strip()

        if not vgname.isalnum():
            return False, "VG name should contain only alphanumeric characters"

        if not self.partition and vgname in self.PartSchemaObj.schema['vg_dict']:
            return False, "VG name '%s' already exists - please modify" %vgname

        #VG must have at least one PV
        newAssocList = self.phys_to_use.getSelection()
        if not newAssocList:
            return False, "VG must use at least one PV"

        if not self.partition:
            extent_size = self.phys_extent.value()
            try:
                extent_size = int(extent_size)
                if extent_size <= 0:
                    return False, "Extent size must be a positive integer"
            except:
                return False, "Extent size must be a positive integer"
                

        return True, 'Success'

    def formAction(self):
        #Precondition: vgname uniqueness/sanity is guaranteed

        #collect widget data into a PartitionRec object
        if self.partition:
            id = self.partition['instid']
        else:
            id = self.PartSchemaObj.getNewPartId()
        partrec = PartitionRec(idpartitions = id)

        oldAssocList = []
        if self.partition:
            PVidmap = self.PartSchemaObj.getPVMap()
            oldAssocList = [k for k,v in PVidmap.items() if v and v == self.partition['name']]
        newAssocList = self.phys_to_use.getSelection()
        oldAssocSet = Set(oldAssocList)
        newAssocSet = Set(newAssocList)

        if self.partition and oldAssocSet == newAssocSet:
            #nothing has changed
            return

        vgname = self.vg_name.value().strip()
        
        for id in oldAssocSet - newAssocSet:
            #handle removed associations
            p = self.PartSchemaObj.getPartRecByPK(id)
            optlst = p['options'].split(';')
            optlst = [x for x in optlst if not x.strip().lower().startswith('vg=')]
            optlst.sort()
            p['options'] = string.join(optlst, ';')

        for id in newAssocSet - oldAssocSet:
            #handle added associations
            p = self.PartSchemaObj.getPartRecByPK(id)
            optlst = p['options'].split(';')
            optlst.append('vg=%s' %vgname)
            optlst.sort()
            p['options'] = string.join(optlst, ';')

        #options
        optlst = ['vg']
        optlst.append('extent=%sM' %self.phys_extent.value())
        partrec['options'] = string.join(optlst, ';')
            
        #name
        partrec['device'] = vgname
        #preserve
        if self.partition:
            partrec['preserve'] = self.PartRec['preserve']
        else:
            partrec['preserve'] = 1     #does this have any effect?


        if self.partition: #we're editing
            self.PartSchemaObj.updatePartRec(partrec)
        else:   #new partition
            self.PartSchemaObj.addPartRec(partrec)


class scrNGEEdit_Finalize(USXBaseScreen):
    name = 'Summary of Changes'
    buttons = [ 'accept_button', 'back_button', 'cancel_button' ]

    def __init__(self, database, kusuApp=None, gridWidth=45):
        USXBaseScreen.__init__(self, database, kusuApp=kusuApp, gridWidth=gridWidth)
        self.__diffNG = None
        self.__plugdir = '/opt/kusu/lib/plugins/ngedit' #FIXME: may need to change

    def setCallbacks(self):
        #for the buttons
        self.buttonsDict['accept_button'].setCallback_(self.doAcceptAction)
        self.buttonsDict['back_button'].setCallback_(self.doBackAction)
        self.buttonsDict['cancel_button'].setCallback_(self.doCancelAction)

    def doBackAction(self):
        return NAV_BACK

    def doCancelAction(self):
        return NAV_QUIT

    def doAcceptAction(self):
        #construct a diff NG object from dict
        diffNGobj = NodeGroup(**self.__diffNG)
        diffNGobj['ngid'] = curNG['ngid']

        if self.__diffNG:   #only if there are changes
            kl.debug('Finalize: prior to DBsync\ndiffNGobj = %s' % str(diffNGobj))
            self.database.beginTransaction()
            try:
                diffNGobj.syncToDB(self.database)
            except Exception,msg:
                self.selector.popupMsg('DB Error', 'DB Update failed with msg = %s' %msg)
                self.database.undoTransaction()
                raise #for testing
                return NAV_NOTHING

            #no exceptions up to this point: successful
            self.database.endTransaction()
            self.selector.popupMsg("DB Update", "Database was successfully updated")

            #clean up scripts
            if 'scripts' in self.__diffNG.keys():
                delScripts = Set(origNG['scripts']) - Set(curNG['scripts'])
                if delScripts:
                    tplstr = "'%s'" + " , '%s'"*(len(delScripts)-1)
                    tplstr = tplstr % tuple(delScripts)
                    query = "select script from scripts where script in (%s)" % tplstr
                    self.database.execute(query)
                    rv = self.database.fetchall()
                    dbScripts = Set([x for x, in rv])   #scripts in use
                    delScripts -= dbScripts
                    for script in delScripts:
                        delscr = os.path.join(CustomScriptDir, script)
                        if os.path.isfile(delscr):
                            os.remove(delscr)
                

        return NAV_FORWARD


    def drawImpl(self):
        self.__diffNG = curNG - origNG
        diffNG = self.__diffNG

        #self.selector.popupMsg("scripts", "curNG: %s\norigNG: %s\ndiffNG=%s" \
        #        %(str(curNG['scripts']),str(origNG['scripts']),str(self.__diffNG)))

        msg = ''
        for field in NodeGroupRec.fields[2:] : #skip the keys
            if field in diffNG.keys():
                msg += "%s: \t%s\n" %(field.upper(),diffNG[field])

        if 'repoid' in diffNG.keys():
            query = '''SELECT reponame,repository,ostype from repos where
                       repoid = %s ''' % diffNG['repoid']
            self.database.execute(query)
            rv = self.database.fetchone()
            rv = [ ifelse(x==None,'',x) for x in rv ]
            msg += "REPO:\n\t| %s | %s | %s |\n" %tuple(rv)

        # go through comps, nets, packs, modules, scripts, parts
        if 'comps' in diffNG.keys():
            compsstr = ''
            if diffNG['comps']:
                if len(diffNG['comps']) == 1:
                    #tuples have a trailing comma when only one element
                    tplstr = "(%s)" %diffNG['comps'][0]
                else:
                    tplstr = str(tuple(diffNG['comps']))
                query = "select cname from components where cid in %s" %tplstr
                self.database.execute(query)
                rv = self.database.fetchall()
                compslst = [x for x, in rv]
                compsstr = '%s' + ', %s'*(len(compslst)-1)
                compsstr = compsstr % tuple(compslst)
            msg += "COMPONENTS SELECTED:\n\t%s\n" %compsstr

        if 'nets' in diffNG.keys():
            netsstr = ''
            if diffNG['nets']:
                if len(diffNG['nets']) == 1:
                    tplstr = "(%s)" %diffNG['nets'][0]
                else:
                    tplstr = str(tuple(diffNG['nets']))
                query = ''' select device,network,netname from networks where
                            netid in %s''' %tplstr
                self.database.execute(query)
                rv = self.database.fetchall()
                rv = [ ifelse(None in x, [ ifelse(y==None,'',y) for y in x ] , list(x)) for x in rv ]
                for record in rv:
                    netsstr += "\t| %s | %s | %s |\n" %tuple(record)
            msg += "NETWORKS SELECTED:\n%s\n" % netsstr
            
        caption = { 'packs': 'OPTIONAL PACKAGES',
                    'scripts': 'OPTIONAL SCRIPTS',
                    'modules': 'MODULES'
                  }
        for link in caption.keys():
            if link in diffNG.keys():
                tmpstr = ''
                if diffNG[link]: #one or more elements
                    if link == 'scripts':
                        #format scripts one per line
                        tmpstr = '%s' + '\n\t%s'*(len(diffNG[link])-1)
                    else:
                        tmpstr = '%s' + ', %s'*(len(diffNG[link])-1)
                    tmpstr = tmpstr % tuple(diffNG[link])
                msg += "%s:\n\t%s\n" %(caption[link],tmpstr)

        if 'parts' in diffNG.keys():
            msg += "PARTITIONS: schema changed\n"

        kl.info("Finalize: diffNG = %s" %str(diffNG))
        #self.selector.popupMsg("diffNG", str(diffNG))

        self.screenGrid = snack.Grid(1, 1)
        self.screenGrid.setField(snack.TextboxReflowed(width=MAXWIDTH, maxHeight=10, 
                text=msg), 0,0, (0,0,0,0), anchorLeft=1)


    def validate(self):
        return True, 'Success'

    def handleCompPlug(self, CompIdList, action):
        if not CompIdList:
            return
        CompIdList = [ int(x) for x in CompIdList ]
        if len(CompIdList) == 1: #special case
            tplstr = '(%s)' % str(CompIdList[0])
        else:
            tplstr = str(tuple(CompIdList))

        query = 'select cname from components where cid in %s' % tplstr
        self.database.execute(query)
        rv = self.database.fetchall()
        CompNameList = [x for x, in rv]

        CompPlugList = []
        for comp in CompNameList:
            flist = glob.glob('%s/*-%s.py' %(self.__plugdir,comp))
            CompPlugList.extend(flist)
        CompPlugList.sort()

        PlugInstList_draw = []
        PlugInstList_run = []
        for plugfile in CompPlugList:
            plugmname = os.path.splitext(os.path.basename(plugfile))[0] #module name
            plugminst = __import__(plugmname)           #module instance
            plugcname = getattr(plugminst, 'NGPlugin')  #class name
            if not issubclass(plugcname, NGEPluginBase):
                raise Exception, 'Invalid NG Plugin Screen class encountered: %s' %plugcname

            plugcinst = plugcname(self.database, self.kusuApp)  #class instance
            plugcinst.ngid = curNG['ngid']
            if action == 'add':
                if plugcinst.isInteractive():
                    PlugInstList_draw.append(plugcinst)
                else:
                    PlugInstList_run.append(plugcinst)
            elif action == 'remove':
                PlugInstList_run.append(plugcinst)

        if PlugInstList_draw:
            ScreenFactory.screens = PlugInstList_draw
            ks = USXNavigator(screenFactory=ScreenFactory, screenTitle="Component Plugin Sequence", showTrail=False)
            ks.run()

        if action == 'add':
            for inst in PlugInstList_run:
                inst.add()
        elif action == 'remove':
            for inst in PlugInstList_run:
                inst.remove()

    def runTool(self,tool, argstr):

        kl.info("Final Actions: Running %s:" %tool)
        cmd = "%s %s" %(tool,argstr)
        p = subprocess.Popen(   cmd, shell=True,
                                stdout = subprocess.PIPE,
                                stderr = subprocess.STDOUT
                            )

        prog_out = kusuwidgets.ProgressOutputWindow(self.selector.mainScreen, \
            '%s progress' %tool, msg='',width=MAXWIDTH+3,height=MAXHEIGHT,scroll=0)
        output = ''

        t1 = time.time()
        line = p.stdout.readline()
        while line:
            output += line
            prog_out.setText(output)
            prog_out.draw()
            prog_out.refresh()
            line = p.stdout.readline()
        time.sleep(2)
        prog_out.close()

        prog_simple = self.selector.popupProgress("%s" %tool, \
            "waiting for %s to terminate" %tool)
        sts = os.waitpid(p.pid,0)
        prog_simple.close()
        t2 = time.time()

        retcode = p.returncode

        if not retcode:
            _title = "%s - success" %tool
            _msg = "%s reported successful return. Please inspect its output:\n" %tool
        else:
            _title = "%s - error" %tool
            _msg = tool + " returned an error, so its operation may be incomplete."  +\
                   " Please refer to ngedit log file"+\
                   " for more detail. You can rerun the command manually as follows:\n"+\
                   cmd + "\nPlease inspect the output below:\n"
        _msg += output

        self.selector.popupMsg(_title, _msg, width = MAXWIDTH)
        kl.info("%s finished in %f sec. Output:\n%s" %(tool, (t2-t1),output))


    def formAction(self):
        if self.__plugdir not in sys.path:
            sys.path.append(self.__plugdir)

        s1 = Set(curNG['comps'])
        s2 = Set(origNG['comps'])
        addedComps = list(s1 - s2)
        removedComps = list(s2 - s1)

        #self.selector.popupMsg("Plugin DEBUG", "(+) %s\n(-) %s" %(str(addedComps),str(removedComps)))
        self.handleCompPlug(addedComps, 'add')
        self.handleCompPlug(removedComps, 'remove')

        #run second-party tools:
        # * if imaged (both disked & diskless)
        #        if changes in (components or packages or repo)
        #            run buildimage (buildimage -n $ngid)

        #  * if imaged (both disked & diskless)
        #        if changes in (modules or repo)
        #            buildinitrd -n $ngid

        #  * all install types
        #    if changes in packages or components
        #        call update -n $ngid -p (nothing after -p)

        #  * if package-based and adding a component with drivers
        #       driverpatch to patch initrd w/ new drivers
        #       driverpatch nodegroup id=curNG['ngid'] arch=$arch

        key_lst = self.__diffNG.keys()
        if ('comps' in key_lst or 'packs' in key_lst or 'repoid' in key_lst) \
             and curNG['installtype'] != 'package' :
            #buildinitrd
            self.runTool('buildinitrd', " -n '%s'" %curNG['ngname'])

        if curNG['installtype'] != 'package' and ('modules' in key_lst or 'repoid' in key_lst):
            #buildimage
            self.runTool("buildimage", " -n '%s'" %curNG['ngname'])

        run_driverpatch = False
        addedComps = [int(x) for x in addedComps]
        if curNG['installtype'] == 'package' and addedComps:
            query = "select dpid from driverpacks where cid in %s" %seq2tplstr(addedComps)
            self.database.execute(query)
            rv = self.database.fetchall()
            if len(rv) >= 1:
                run_driverpatch = True

        if run_driverpatch:
            #driverpatch
            self.runTool('driverpatch', " nodegroup name='%s'" %curNG['ngname'])

        if 'packs' in key_lst or 'comps' in key_lst:
            #cfmsync
            run_update = self.selector.popupYesNo("CFM Sync", "Do you wish to update "+\
                        "the nodes in this nodegroup now?", defaultNo=True)
            if run_update:
                self.runTool('cfmsync', "-n '%s' -p" %curNG['ngname'])
            else:
                cmd = 'cfmsync'+ " -n '%s' -p" %curNG['ngname']
                self.selector.popupMsg("cfmsync reminder", "Please update the nodes manually"+\
                    " at your earliest convenience by running\n%s" %cmd)

        self.selector.popupMsg("You are DONE!", "Nodegroup modification is now complete!")

class scrNGEEdit_Scripts(USXBaseScreen):
    name = 'Custom Scripts'
    msg = 'Enter the custom script path'
    buttons = ['next_button', 'back_button','add_button', 'delete_button', 'cancel_button']

    def __init__(self, database, kusuApp=None, gridWidth=45):
        USXBaseScreen.__init__(self, database, kusuApp=kusuApp, gridWidth=gridWidth)
        self.__allscrpath = CustomScriptDir
        self.__copiedfiles = []

    def setCallbacks(self):

        #for the buttons
        self.buttonsDict['next_button'].setCallback_(self.doForwardAction)
        self.buttonsDict['back_button'].setCallback_(self.doBackAction)
        self.buttonsDict['cancel_button'].setCallback_(self.doCancelAction)
        self.buttonsDict['add_button'].setCallback_(self.doAddAction)
        self.buttonsDict['delete_button'].setCallback_(self.doDeleteAction)
        #for hotkeys
        self.hotkeysDict['F12'] = self.F12Action

    def F12Action(self):
        self.selector.popupMsg("Internal State", "curNG['scripts']=%s\ncopiedfiles= %s" \
                 %(str(curNG['scripts']), str(self.__copiedfiles)))

        return NAV_IGNORE

    def doCancelAction(self):
        for curscr in self.__copiedfiles:
            os.remove(os.path.join(self.__allscrpath,curscr))
        self.__copiedfiles = []
        return NAV_QUIT

    def doForwardAction(self):
        return NAV_FORWARD

    def doBackAction(self):
        return NAV_BACK

    def doDeleteAction(self):
        if not self.__curscr:
            return NAV_NOTHING

        curscr = self.__curscr.current()
        assert(curscr in curNG['scripts'])
        del curNG['scripts'][curNG['scripts'].index(curscr)]
        if curscr in self.__copiedfiles:
            #it's been copied in the current editing session
            os.remove(os.path.join(self.__allscrpath,curscr))
            del self.__copiedfiles[self.__copiedfiles.index(curscr)]
            
        return NAV_NOTHING

    def doAddAction(self):
        newscr = self.__newscr.value().strip()
        if not newscr:
            self.selector.popupMsg("Invalid script specification", "Please enter script location")
            return NAV_NOTHING

        head,tail = os.path.split(newscr)
        if not head:
            #no path given - assume default
            if not os.path.isfile(os.path.join(self.__allscrpath,tail)):
                self.selector.popupMsg("Invalid script specification", "Specified script was not found in the script repo")
                return NAV_NOTHING

        else:
            #path was specified
            if not os.path.isabs(newscr):
                self.selector.popupMsg("Invalid script path specification", "Script path must be absolute")
                return NAV_NOTHING
            if not os.path.isfile(newscr):
                self.selector.popupMsg("Script not found", "Please ensure path correctness")
                return NAV_NOTHING
            #newscr is an existing file on the f.s.
            if os.path.realpath(os.path.normpath(newscr)) != \
                            os.path.normpath(os.path.join(self.__allscrpath,tail)):
                #dealing with an existing file outside script repo
                #ensure name uniqueness
                self.database.execute("select script from scripts where script='%s'" %tail)
                rv = self.database.fetchall()
                if len(rv) >=1 or tail in os.listdir(self.__allscrpath):
                    self.selector.popupMsg("Script name verification", "Please rename the script. Name conflict.")
                    return NAV_NOTHING
                else:
                    shutil.copy(newscr,self.__allscrpath)
                    self.__copiedfiles.append(tail)

        #update curNG
        if not curNG['scripts']:
            curNG['scripts'] = []
        if not tail in curNG['scripts']:
            curNG['scripts'].append(tail)

        return NAV_NOTHING

    def drawImpl(self):

        self.screenGrid = snack.Grid(1, 2)
        labelTxt = 'New Script: '

        w = self.gridWidth
        if curNG['scripts']:
            w = max([len(x) for x in curNG['scripts']] + [MAXWIDTH*3/4])
            self.__curscr = snack.Listbox(height=10, scroll=1, width=w,returnExit=1, showCursor=0)
            for script in sorted(curNG['scripts']):
                self.__curscr.append(script, item=script)
        else:
            self.__curscr = None

        self.__newscr = kusuwidgets.LabelledEntry(labelTxt=labelTxt, text="",width=w-len(labelTxt))

        if self.__curscr:
            self.screenGrid.setField(self.__curscr, 0,0, anchorLeft=1)
        else:
            self.screenGrid.setField(snack.TextboxReflowed(text="Currently no scripts associated.",
                                     width=w),0,0, (0,0,0,1), anchorLeft=1)
        self.screenGrid.setField(self.__newscr, 0,1, anchorLeft=1)

    def validate(self):
        txt = self.__newscr.value().strip()
        if txt:
            return False, "Please leave the entry field empty to proceed to the next screen."
        return True, 'Success'

    def formAction(self):
        pass
        

class NGEApp(KusuApp):

    def __init__(self):
        KusuApp.__init__(self)

        self.__db = KusuDB()
        self.action = NGE_TUI
        self.ng = None
        self.ngnew = None

        try:
            self.__db.connect(user='apache', dbname='kusudb')
        except Exception,msg:
            sys.stderr.write('Problems establishing database connection. Error: %s' %msg)
            sys.exit(1)

        # setup the CL parser
        self.parser.add_option('-d', '--delete',    dest='ngdel')
        self.parser.add_option('-c', '--copy',      dest='ngsrc')
        self.parser.add_option('-n', '--new',       dest='ngnew')
        self.parser.add_option('-s', '--stale',     dest='ngstale')
        self.parser.add_option('-l', '--list',      dest='list', action="store_true")
        self.parser.add_option('-p', '--print',     dest='ngprint')
        
    def printHelp(self):
        self.parser.print_help()

    def parse(self):
        ''' parse the CL, populate options dict, & define self.action
        '''
        (options, args) = self.parser.parse_args()
        #print 'options = ', options
        #print 'args = ', args
        #print 'class(options) = ', options.__class__

        if args:
            self.stderrMessage('ngedit: No arguments expected - encountered args = %s\n',
                                string.join(args,', '))
            self.printHelp()
            sys.exit(1)

        if bool(options.ngsrc) ^ bool(options.ngnew):
            #exactly one of them was specified
            self.stderrMessage('ngedit: both ngsrc and ngdst must be specified to copy a node group\n')
            self.printHelp()
            sys.exit(1)

        if options.list:
            self.action = NGE_PRNALL
        elif options.ngdel:
            self.action = NGE_DEL
            self.ng = options.ngdel
        elif options.ngsrc:
            self.action = NGE_CPY
            self.ng = options.ngsrc
            self.ngnew = options.ngnew
        elif options.ngstale:
            self.action = NGE_PRNSTL
            self.ng = options.ngstale
        elif options.ngprint:
            self.action = NGE_PRNONE
            self.ng = options.ngprint

    def run(self):
        if self.action == NGE_TUI:
            ScreenFactory.screens = [
                                        scrNGEMain(database=self.__db, kusuApp=self),
                                    ]

            ks = USXNavigator(screenFactory=ScreenFactory, screenTitle="Node Group Editor", showTrail=False)
            ks.run()

        elif self.action == NGE_CPY:
            query = "select ngid from nodegroups where ngname = '%s'" %self.ng
            self.__db.execute(query)
            rv = self.__db.fetchone()
            if not rv:
                self.stdoutMessage("ngedit: nodegroup '%s' not found in the database\n", self.ng)
                sys.exit(self.action)
            ngid = rv[0]

            query = "select ngid from nodegroups where ngname = '%s'" %self.ngnew
            self.__db.execute(query)
            rv = self.__db.fetchone()
            if rv:
                self.stdoutMessage("ngedit: nodegroup '%s' already exists. Please change.\n", self.ngnew)
                sys.exit(self.action)

            ngsrc = NodeGroup(ngid = ngid)
            ngsrc.syncFromDB(self.__db)
            ngsrc[ngsrc.PKfld] = None    #give it new identity
            ngsrc['ngname'] = self.ngnew
            ngsrc.syncToDB(self.__db)

        elif self.action == NGE_DEL:
            query = "select ngid from nodegroups where ngname= '%s'" %self.ng
            self.__db.execute(query)
            rv = self.__db.fetchone()
            if not rv:
                self.stdoutMessage("ngedit: nodegroup '%s' not found in the database\n", self.ng)
                sys.exit(self.action)
            ngid = rv[0]

            #delete only if no hosts using it
            query = "select nid from nodes where ngid = %s" % ngid
            self.__db.execute(query)
            rv = self.__db.fetchall()
            if len(rv) > 0:
                self.stdoutMessage("ngedit: %s node(s) are still using nodegroup '%s'." +\
                                    " Deletion disallowed\n", len(rv),self.ng)
                sys.exit(self.action)

            #beauty
            ngdel = NodeGroup(ngid = ngid)
            ngdel.syncFromDB(self.__db)
            ngdel.eraseFromDB(self.__db)

        elif self.action == NGE_PRNALL:
            self.__db.execute('select ngname,ngdesc,type from nodegroups')
            rv = self.__db.fetchall()
            rv = [ ifelse(None in x, [ ifelse(y==None,'',y) for y in x ] , list(x)) for x in rv ]
            for ngname,ngdesc,type in rv:
                print "%s : %s : %s" %(ngname,ngdesc,type)

        elif self.action == NGE_PRNSTL:
            query = ''' select n.name, n.lastupdate, n.rack, n.rank from nodes n,
                        nodegroups ng where n.state = 'Expired' and n.ngid = ng.ngid
                        and ng.ngname = '%s' ''' % self.ng
            self.__db.execute(query)
            rv = self.__db.fetchall()
            rv = [ ifelse(None in x, [ ifelse(y==None,'',y) for y in x ] , list(x)) for x in rv ]

            for name,lastup,rack,rank in rv:
                print "%s | %s | %s | %s" %(name,lastup,rack,rank)

        elif self.action == NGE_PRNONE:
            self.__db.execute("select ngid from nodegroups where ngname = '%s'" %self.ng)
            rv = self.__db.fetchone()
            if not rv:
                self.stdoutMessage("ngedit: nodegroup '%s' not found in the database\n", self.ng)
                sys.exit(self.action)
            ngid = rv[0]
            ngprn = NodeGroup(ngid = ngid)
            ngprn.syncFromDB(self.__db)
            ngprn.prettyPrint()

            #print repo
            reponame = None
            if ngprn['repoid']:
                self.__db.execute("select reponame from repos where repoid = %s " %ngprn['repoid'])
                rv = self.__db.fetchone()
                if rv:
                    reponame = rv[0]
            justval = len("Nodename Format: ")
            print "Repository: ".ljust(justval), reponame

            #print inSync info
            query = "select nid from nodes where ngid = %s and state = 'Expired'" % ngid
            self.__db.execute(query)
            rv = self.__db.fetchall()
            inSync = True
            if len(rv) > 0:
                inSync = False
            print "In Sync: ".ljust(justval), inSync

            # print all the links now
            # oneliners: components, modules, packages, scripts
            compsstr = None
            if ngprn['comps'] :
                ngprn['comps'] = [ int(x) for x in ngprn['comps'] ]
                query = ''' select k.rname,c.cname,c.cdesc from kits k, components c
                             where c.kid = k.kid and c.cid in %s ''' %seq2tplstr(ngprn['comps'])
                self.__db.execute(query)
                rv = self.__db.fetchall()
                compsstr = '\n'
                for rname,cname,cdesc in rv:
                    compsstr += "\t%s : %s : %s\n" %(rname,cname,cdesc)
            print "Components: ".ljust(justval), compsstr

            if ngprn['packs']:
                #assume min(columns) >= 80
                ngprn['packs'].sort()
                packstr = ''
                for i in xrange(len(ngprn['packs'])):
                    if i%2 == 0:
                        packstr += '\t' + ngprn['packs'][i].ljust(36)
                    else:
                        packstr += ngprn['packs'][i].ljust(36)+'\n'
                print 'Packages:\n' + packstr
            else:
                print 'Packages: '.ljust(justval), None

            if ngprn['modules']:
                ngprn['modules'].sort()
                print 'Modules:\n\t', string.join(ngprn['modules'], ', ')
            else:
                print 'Modules: '.ljust(justval), None
            if ngprn['scripts']:
                ngprn['scripts'].sort()
                print 'Scripts:\n\t', string.join(ngprn['scripts'], ', ')
            else:
                print 'Scripts: '.ljust(justval), None

            #extended info on: networks, partition schema
            #for partitions follow the TUI case: build schema and pretty print
            if ngprn['parts']:
                #work around Kusu bug 347
                for p in ngprn['parts']:
                    if p['options'] == None:
                        p['options'] = ''
                    if p['mntpnt'] == None:
                        p['mntpnt'] = ''
                    if p['device'] == None:
                        p['device'] = ''

                schemaObj = PartSchema()
                schemaObj.mycreateSchema(ngprn['parts'])
                print "Partition Schema:"
                str2display = str(schemaObj)
                strlst = ['\t'+x for x in string.split(str2display,'\n')]
                print string.join(strlst,'\n')
            else:
                print "Partition Schema:".ljust(justval), None

            if ngprn['nets']:
                cols = [ ['Device','Network','Subnet','Description'] ]
                self.__db.execute('''select max(char_length(device)),max(char_length(network))
                                         , max(char_length(subnet)), max(char_length(netname))
                                         from networks''')

                rv = self.__db.fetchone()
                cols.append([int(x) for x in rv]) #justification values
                headstr = ''
                for i in xrange(len(cols[0])): #for all columns
                    cols[1][i] = max(cols[1][i], len(cols[0][i]))+1 #make room for the label
                    headstr += cols[0][i].ljust(cols[1][i])
                headstr = headstr[:MAXWIDTH]
                print "Networks:\n\t", headstr

                query = "select device, network, subnet, netname, netid from networks"
                self.__db.execute(query)
                rv = self.__db.fetchall()

                for record in rv:
                    record = list(record) #convert to list
                    netid = record.pop()
                    entrystr = ''
                    for i in xrange(len(record)): #construct an entry string
                        entrystr += record[i].ljust(cols[1][i])
                    if len(entrystr) > MAXWIDTH:
                        entrystr = entrystr[:MAXWIDTH - len('...')] + '...'
                    print '\t' + entrystr
            else:
                print "Networks: ".ljust(justval), None
                        

if __name__ == '__main__':
    NGEinst = NGEApp()
    NGEinst.parse()
    NGEinst.run()
