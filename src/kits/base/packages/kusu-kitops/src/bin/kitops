#!/usr/bin/python -u
# $Id: kitops 3016 2008-01-12 01:26:09Z mike $
#
# Copyright 2007 Platform Computing Inc.
#
# Licensed under GPL version 2; See LICENSE for details.
#

import sys
import os
import shutil
import cPickle as cpickle
from path import path
from optparse import SUPPRESS_HELP
from tempfile import mkdtemp
from ConfigParser import ConfigParser
from primitive.support.yum import YumRepo
from kusu.util.kits import processKitInfo
from primitive.fetchtool.commands import FetchCommand
from kusu.repoman import tools
from primitive.support.rpmtool import RPM
from primitive.core.errors import FetchException

if os.getuid() != 0:
    sys.stderr.write('You need to be root to run kitops.\n')
    sys.exit(1)

import kusu.util.log as kusulog
kl = kusulog.getKusuLog()
kl.addFileHandler('/var/log/kusu/kusu-kitops.log')
kl = kusulog.getKusuLog('kitops-app')

import kusu.core.database as db
from kusu.core.app import KusuApp
from kusu.kitops.kitops import KitOps
from kusu.kitops.action import UpdateAction
from kusu.boot.distro import DistroInstallSrcBase
from kusu.util.errors import *

EMOUNT_FAIL     = -1
EKITLOC_FAIL    = -2
EKITADD_FAIL    = -3
EKITDEL_FAIL    = -4
EKITUP_FAIL     = -5
EKITLST_FAIL    = -6
EDB_FAIL        = -7
EKIT_BAD        = -8
EBAD_OP         = -9

KITOP_NONE  = 0x00
KITOP_ADD   = 0x01
KITOP_DEL   = 0x02
KITOP_UP    = 0x04
KITOP_LST   = 0x08
KITOP_RLST  = 0X10
PROCESS_ACTION_QUEUE = 0x11

class KitOpsApp(KusuApp):
    def __init__(self, koinst):
        """Create instance of KitOpsApp. koinst is a KitOps instance."""

        KusuApp.__init__(self)

        self.action_queue = {}
        self.koinst = koinst
        self.kitop = KITOP_NONE
        self.kit_name = ''
        self.kit_ver = ''
        self.kit_arch = ''
        self.skip_confirm = False
        self.cachepath = path('/opt/kusu/var/cache/kitops')
        self.channel = 'rhn://rhel-x86_64-server-hpc-5/'

        # if this is set to true, the following default assumptions are made
        # 1) An OS Kit only has 1 CD.
        # 2) In a meta kit, all kits are selected for addition
        # 3) confirmations are skipped
        self.suppress_questions = False

        # We only want one instance of kitops running at any one time.
        self.force_single_instance()


        def mutexAction(option, opt_str, value, parser):
            if parser.values.action is not None:
                self.printHelp()
                sys.stderr.write('Only one of -a/--add, -e/--remove, -l/--list, -r/--remotelist or -u/--update is supported.\n')
                sys.exit(EBAD_OP)
            elif '-a' in option._short_opts:
                setattr(parser.values, option.dest, 'add')
            elif '-e' in option._short_opts:
                setattr(parser.values, option.dest, 'delete')
            elif '-l' in option._short_opts:
                setattr(parser.values, option.dest, 'list')
            elif '-r' in option._short_opts:
                setattr(parser.values, option.dest, 'remotelist')
            elif '-u' in option._short_opts:
                setattr(parser.values, option.dest, 'update')


        # setup command line parser
        self.parser.add_option('-a', '--add', dest='action',
                               help=self._('kitops_usage_add'),
                               action='callback', callback=mutexAction)
        self.parser.add_option('-l', '--list', dest='action',
                               help=self._('kitops_usage_list'),
                               action='callback', callback=mutexAction)
        self.parser.add_option('-r', '--remotelist', dest='action',
                               help=self._('kitops_usage_remotelist'),
                               action='callback', callback=mutexAction)
        self.parser.add_option('-u', '--update', dest='action',
                               help=self._('kitops_usage_update'),
                               action='callback', callback=mutexAction)

        self.parser.add_option('-e', '--remove', dest='action',
                               help=self._('kitops_usage_remove'),
                               action='callback', callback=mutexAction)

        self.parser.add_option('-m', dest='media',
                               help=self._('kitops_usage_media'))

        self.parser.add_option('-k', '--kit', dest='kit',
                               help=self._('kit'))

        self.parser.add_option('-i', '--kid', dest='kid',
                               help=self._('kid'))

        self.parser.add_option('-o', '--kitversion', dest='kitversion',
                               help=self._('kitversion'))
        self.parser.add_option('-c', '--kitarch', dest='kitarch',
                               help=self._('kitarch'))

        self.parser.add_option('--dbdriver', dest='dbdriver',
                               help=self._('Database driver (sqlite, mysql,postgres)'))
        self.parser.add_option('--dbdatabase', dest='dbdatabase',
                               help=self._('Database'))
        self.parser.add_option('--dbuser', dest='dbuser',
                               help=self._('Database username'))
        self.parser.add_option('--dbpassword', dest='dbpassword',
                               help=self._('Database password'))
        self.parser.add_option('-y', '--yes', dest='skip_confirm',
                               help=self._('kitops_usage_skip_confirm'),
                               action='store_true', default=False)
        self.parser.add_option('-v', '--version', dest='version',
                               help=self._('Display version'),
                               action='store_true', default=False)
        self.parser.add_option('-p', '--prefix', dest='prefix',
                               help=SUPPRESS_HELP),
        self.parser.add_option('-s','--suppress-questions',
                               dest='suppress_questions',
                               action='store_true',default=False,
                               help=SUPPRESS_HELP)


    def parseArgs(self):
        (options, args) = self.parser.parse_args()
        kl.debug("options: %s", options)
        kl.debug("args: %s", args)

        if args:
            sys.stderr.write("Error: unclaimed arguments: %s\n\n" % args)
            self.printHelp()
            sys.exit(1)

        if options.version:
            global version
            self.stdoutMessage('Kitops Version %s\n', self.version)
            sys.exit(0)

        dbdriver = os.getenv('KUSU_DB_ENGINE')
        if not dbdriver or dbdriver not in ['mysql','postgres']:
            dbdriver = 'mysql' # default to mysql

        dbdatabase = 'kusudb'
        dbuser = 'apache'
        dbpassword = None

        if options.dbdriver:
            dbdriver = options.dbdriver
        if options.dbdatabase:
            dbdatabase = options.dbdatabase
        if options.dbuser:
            dbuser = options.dbuser
        if options.dbpassword:
            dbpassword = options.dbpassword

        try:
            self.__db = db.DB(dbdriver, dbdatabase, dbuser, dbpassword)
            self.koinst.setDB(self.__db)
        except UnsupportedDriverError, e:
            self.logErrorEvent('Database error: ' + e.args[0])
            sys.exit(EDB_FAIL)

        # Now we will just perform a quick query from the DB to make sure the
        # DB connection we established is correct.
        try:
            self.koinst.findKits('not expecting', 1, 'result', 'at all')
        except:
            self.logErrorEvent("Database error. " + \
                               "Please check database configuration.")
            sys.exit(EDB_FAIL)

        #suppress questions if required
        self.suppress_questions = options.suppress_questions
        #confirmations are skipped if questions are not asked
        self.skip_confirm = options.suppress_questions or options.skip_confirm

        if options.action == 'add':
            kit_media = options.media
            if not kit_media:
                if self.suppress_questions:
                    kl.debug('Kit media not specified in silent mode')
                    self.logErrorEvent('Kit media not specified in silent mode')
                    sys.exit(EKITLOC_FAIL)
                else:
                    if not options.kid:
                        kit_media = self.determineKitMedia()

            # to indicate which kit to install from a metakit
            self.kit_name = options.kit
            self.kit_id = options.kid
            self.kit_ver = options.kitversion
            self.kit_arch = options.kitarch
            self.koinst.setKitMedia(kit_media)
            self.kitop = KITOP_ADD
        elif options.action == 'update':
            kit_media = options.media
            self.koinst.setKitMedia(kit_media)

            update_action = UpdateAction(self.__db, self.koinst)
            run_args = { 'old_kit_id': options.kid,
                         'kits': self.mountAndParseKitMedia() }

            self.action_queue[update_action] = run_args
            self.kitop = PROCESS_ACTION_QUEUE
        elif options.action == 'delete':
            self.kit_name = options.kit
            self.kit_id = options.kid
            self.kit_ver = options.kitversion
            self.kit_arch = options.kitarch
            self.kitop = KITOP_DEL
        elif options.action == 'list':
            self.kit_name = options.kit
            self.kit_id = options.kid
            self.kit_ver = options.kitversion
            self.kit_arch = options.kitarch
            self.kitop = KITOP_LST
        elif options.action == 'remotelist':
            self.kit_name = options.kit
            self.kit_id = options.kid
            self.kit_ver = options.kitversion
            self.kit_arch = options.kitarch
            self.kitop = KITOP_RLST


        if options.prefix:
            kl.debug('Setting prefix to %s', options.prefix)
            self.koinst.setPrefix(options.prefix)
        else:
            self.koinst.setPrefix('/')


    def getActionDesc(self):
        if self.kitop == KITOP_ADD:
            return "Add Kit"
        elif self.kitop == KITOP_DEL:
            return "Delete Kit"
        elif self.kitop == KITOP_LST:
            return "List Kits"
        elif self.kitop == KITOP_RLST:
            return "List remote kits"
        else:
            return KusuApp.getActionDesc(self)

    def run(self):
        '''The main body of the application.  '''

        self.parseArgs()

        if self.kitop == KITOP_ADD:

            if self.kit_id:
                opt = self.kit_id
                # Remote kit_id will always be in the form '2-3' where 2 is repoid and 3 is kitid
                if opt.find('-'):
                    self.runAddRemoteKit(self.kit_id)
            else:
                self.runAdd()

        elif self.kitop == KITOP_DEL:
            kl.debug('Performing delete operation')

            kits = self.koinst.findKits(self.kit_name, self.kit_id,
                                        self.kit_ver, self.kit_arch)

            msg = 'The above kits will be removed.\n'

            if not kits:
                if self.kit_id:
                    msg = "Kit '%s" % self.kit_id
                else:
                    msg = "Kit '%s" % self.kit_name
                    if self.kit_ver:
                        msg += '-%s' % self.kit_ver
                    if self.kit_arch:
                        msg += '-%s' % self.kit_arch
                msg += "' is not in the database"
                self.logErrorEvent(msg)
                sys.exit(EKITDEL_FAIL)
            elif confirm(kits, msg, self.skip_confirm):
                try:
                    self.koinst.deleteKit(self.kit_name, self.kit_id,
                                          self.kit_ver, self.kit_arch)
                except (AssertionError, KitNotInstalledError), e:
                    kl.debug('FAIL performing delete operation')
                    self.logErrorEvent(e.args[0])
                    sys.exit(EKITDEL_FAIL)
                except DeleteKitsError, e:
                    kl.debug('FAIL perfoming delete operation')
                    for error in e.args[0]:
                        self.logErrorEvent(error)
                    sys.exit(EKITDEL_FAIL)
            else:
                kl.debug('Deletion confirmation aborted!')

            self.logEvent(self._("kitops_event_deleted_kit") % self.kit_name,
                          toStdout=False)
            kl.debug('SUCCESS performing delete operation')

        elif self.kitop == KITOP_LST:
            self.runListKit()

        elif self.kitop == KITOP_RLST:
            self.runListRemoteKit()
        elif self.kitop == PROCESS_ACTION_QUEUE:
            for action, run_args in self.action_queue.iteritems():
                try:
                    action.run(**run_args)
                except KitopsError, e:
                    sys.stderr.write("ERROR: %s\n" % e)
                    # TODO: move the error codes into the KitopsAction class
                    # hierarchy, and have the action return its own error code.
                    sys.exit(EKIT_BAD)

        else:
            kl.debug('Unknown operation requested: %d', self.kitop)
            self.printHelp()
            return EBAD_OP

        return 0

    def getRemoteRepoConfig(self, urlfile):
        """read the .conf file at /opt/kusu/etc/remoterepo.conf and return dict with repo name and url"""

        if os.path.isfile(urlfile):
            repodict={}
            cp = ConfigParser()
            cp.read(urlfile)

            for section in cp.sections():
                if section == 'rhel':
                    if cp.get(section, 'enabled') == str(1) and os.path.isfile('/etc/sysconfig/rhn/systemid'):
                        p = cp.get(section, 'conf')
                        g = tools.getConfig(p)
                        repodict[section] = g[section]['url']
                        if cp.get(section, 'channel'):
                            self.channel = cp.get(section, 'channel')
                else:
                    if cp.get(section, 'enabled') == str(1):
                        repodict[section] = cp.get(section, 'url')
            return repodict

    def cacheKitInfo(self, repo, repoid, url):
        """cache the kitinfo files of all the kit rpm in the cache directory"""

        kusu_root = path(os.environ.get('KUSU_ROOT', '/opt/kusu'))
        cachepath = self.cachepath +'/'+ repo

        if not cachepath.isdir():
            os.makedirs(cachepath +'/repodata')

        self.cacheRepoMD(repo, url)

        if repo == 'rhel':
            self.getRHNFile(url, '/repodata/primary.xml.gz', cachepath)
            y = YumRepo('file://'+ cachepath)
        else:
            y = YumRepo(url)

        p = y.getPrimary()
        kitid = 1
        kitdict = {}
        for kit in p.keys():
            if kit.startswith('kit-'):

                for arch in p[kit].keys():
                    tempdir = path(mkdtemp(suffix='-kitops'))
                    choice = p[kit][arch][0]

                    if repo == 'rhel':
                        pkg = choice.filename
                        self.getRHNFile(url, pkg.basename(), tempdir)
                        tmppath= tempdir +'/'+pkg.basename()
                        r = RPM(str(tmppath))
                        r.extract(tempdir)
                    else:
                        choice.extract(tempdir)

                    for file in tempdir.files():
                        if file.basename()=='kitinfo':
                            kit, components = processKitInfo(file)
                            kitdict[str(repoid)+'-'+ str(kitid)] = url +'/'+ kit['pkgname'] +'-'+ kit['version'] +'-'+ kit['release'] +'.'+kit['arch']+'.rpm'
                            os.rename(tempdir +'/kitinfo', cachepath +'/'+ str(repoid) +'-'+ str(kitid)+'_kitinfo')
                            kitid = kitid + 1
                            break
                    tempdir.rmtree()
        self.generateCacheFile(repo, kitdict)
        return

    def getMaxRepoID(self):
        """generate new repo id to ensure no duplication"""
        cachepath = self.cachepath
        rlist=[]

        for root, dirs, files in os.walk(cachepath, True):
            for f in files:
                if f.find('kitinfo') >=0:
                    rlist.append(int(f[:f.find('-')]))
                    break

        if rlist == []:
            return 1
        else:
            return max(rlist)+ 1


    def runListRemoteKit(self):
        kl.debug('Performing remote listing operation')

        headers = ['Kit', 'Kid', 'Description', 'Version', 'Release', 'Architecture', 'OS Kit',
                   'Removable', 'Supported OS', 'Repositories', 'Node Groups']

        kusu_root = path(os.environ.get('KUSU_ROOT', '/opt/kusu'))
        urlfile = kusu_root + '/etc/remoterepo.conf'
        cachepath = self.cachepath

        repodict= self.getRemoteRepoConfig(urlfile)

        for repo, url in repodict.iteritems():

            if not self.verifyCacheChecksum(repo, url):
                repoid = self.getMaxRepoID()
                self.cacheKitInfo(repo, repoid, url)

            repocache = cachepath.realpath()/repo

            for filename in repocache.files('*kitinfo*'):
                f = filename.basename()
                kit, components = processKitInfo(filename)
                os_set=set()
                if components:
                    for c in components:
                        for ostype in c['os']:
                            os_set.add(ostype['name']+'-'+ostype['major']+'.'+ostype['minor']+'-'+ostype['arch'])
                if kit:
                    print "%s:\t\t%s" % (headers[0], kit['name'])
                    print "%s:\t\t%s" % (headers[1], f[:f.find('_')])
                    print "%s:\t%s" % (headers[2], kit['description'])
                    print "%s:\t%s" % (headers[3], kit['version'])
                    print "%s:\t%s" % (headers[4], kit['release'])
                    print "%s:\t%s" % (headers[5], kit['arch'])
                    print "%s:\t%s" % (headers[9], repo)
                    print "%s:\t%s" % (headers[7], kit['removable'])
                    print "%s:\t%s" % (headers[8], ', '.join(os_set))
                    sys.stdout.write('\n\n')


    def getRHNFile(self, url, filename, dest):

        if not dest.isdir():
            os.makedirs(dest +'/repodata')

        if filename.find('repodata') >= 0:
            dest = dest + '/repodata'
            if not dest.isdir():
                os.makedirs(dest)

        if dest.isdir():
            fc = FetchCommand(uri=self.channel + filename,
                              fetchdir=False,
                              destdir=dest,
                              overwrite=True,
                              systemid=open('/etc/sysconfig/rhn/systemid', 'r'),
                              up2dateURL=url)
            status, dest = fc.execute()


    def cacheRepoMD(self, repo, url):
        """fetch the repomd.xml from repository and cache in the repo cache directory"""

        cachepath = self.cachepath +'/'+ repo

        if not cachepath.isdir():
            os.makedirs(cachepath +'/repodata')

        if repo == 'rhel':
            self.getRHNFile(url, '/repodata/repomd.xml', cachepath)
        else:
            fc = FetchCommand(uri=url +'/repodata/repomd.xml',
                              fetchdir=False,
                              destdir= cachepath +'/repodata',
                              overwrite=True)
            status, dest = fc.execute()


    def generateCacheFile(self, repo, kitdict):
        """create cachekits.pck from the kitdict with the rkid and url"""
        cachepath = self.cachepath +'/'+ repo

        if not cachepath.isdir():
            os.makedirs(cachepath)

        outfile = open(cachepath +'/cachekits.pck', 'wb')
        cpickle.dump(kitdict, outfile)
        outfile.close()

    def retrieveCacheKitURL(self, rkid):
        """return the root path of the cachekit.pck file and the rkid, kit url in dict form"""
        cachepath = self.cachepath

        for root, dirs, files in os.walk(cachepath, True):
           if files.count('cachekits.pck') > 0:
               f = os.path.join(root, 'cachekits.pck')
               if os.path.isfile(f):
                   infile = open(f, 'rb')
                   kitdict = cpickle.load(infile)

                   for i in kitdict.keys():
                       if i == rkid:
                           infile.close()
                           return root, kitdict
                   infile.close()
        return "", {}


    def retrieveCacheURL(self, rkid):
        """find the url of the remote kit from the rkid in the cachekits.pck"""

        kusu_root = path(os.environ.get('KUSU_ROOT', '/opt/kusu'))
        cachepath = kusu_root + '/var/cache/kitops'
        root, kitdict = self.retrieveCacheKitURL(rkid)

        return root.basename(), kitdict[rkid]

    def verifyCacheChecksum(self, repo, url):
        """check if the cache repo information is updated by fetching repomd.xml and comparing the checksums"""
        kusu_root = path(os.environ.get('KUSU_ROOT', '/opt/kusu'))
        cachepath = self.cachepath +'/'+ repo

        if cachepath.isdir():
            r={}
            l={}
            local = YumRepo('file://'+ cachepath)
            try:
	        l=local.getRepoMD()
            except FetchException, e:
                kl.error(e)
                print "Unable to retrieve repomd.xml file in cache directory [%s]\n" % repo

            if repo == 'rhel':
                tmpdir = path(mkdtemp(suffix='-kitops'))
                self.getRHNFile(url, '/repodata/repomd.xml', tmpdir)
                remote=YumRepo('file://'+ tmpdir)
                try:
                    r=remote.getRepoMD()
                except FetchException, e:
                    kl.error(e)
                    print "Unable to access rhhpc server\n"
                tmpdir.rmtree()
            else:
                remote = YumRepo(url)
                try:
                    r=remote.getRepoMD()
                except FetchException, e:
                    kl.error(e)
                    print "Unable to access remote repository [%s]\n" % repo

            if l and r:
                return self.compareCheckSum(local.repo, remote.repo)
        return False


    def compareCheckSum(self, local, remote):
        """Compare the primary.xml.gz checksum value from the local repomd.xml
           and the remote repomd.xml"""
        return local['primary']['checksum'][0] == remote['primary']['checksum'][0] and \
               local['primary']['checksum'][1] == remote['primary']['checksum'][1]


    def verifyKitUpdated(self, rkid):
        """check if the rkid of the kit to be added is up-to-date"""
        kusu_root = path(os.environ.get('KUSU_ROOT', '/opt/kusu'))
        cachepath = kusu_root + '/var/cache/kitops'

        root, kitdict = self.retrieveCacheKitURL(rkid)

        if root and kitdict:
            kpath, krepo = os.path.split(root)
            kurl, krpm = os.path.split(kitdict[rkid])
            return self.verifyCacheChecksum(krepo, kurl)
        return False


    def runAddRemoteKit(self, rkid):
        kl.debug('Performing remote add kits operation')

        kusu_root = path(os.environ.get('KUSU_ROOT', '/opt/kusu'))
        cachepath = kusu_root + '/var/cache/kitops'

        if not self.verifyKitUpdated(rkid):
            print "Remote repository has been updated and kit id may have changed. Please do kitops -r\n"
            sys.exit(-1)
        repo, rpmurl = self.retrieveCacheURL(rkid)
        cachedir = os.path.join(cachepath, repo)
        url, krpm = os.path.split(rpmurl)

        if cachedir:
            tmpdir = path(mkdtemp(suffix='-kitops'))

            for f in cachedir.files():
                if f.find(str(rkid)+'_kitinfo') >= 0:
                    kit, components = processKitInfo(f)

                    if kit.has_key('filenames'):
                        for c in kit['filenames']:

                            if repo == 'rhel':
                                self.getRHNFile(url, c, tmpdir)
                            else:
                                urlc = os.path.join(url, c)

                                fc = FetchCommand(uri=urlc,
                                                  fetchdir=False,
                                                  destdir=tmpdir,
                                                  overwrite=False)
                                status, dest = fc.execute()
            kit_media = tmpdir
            self.koinst.setKitMedia(kit_media)
            self.runAdd()
            tmpdir.rmtree()


    def runAdd(self):
        kl.debug('Performing add operation')
        self.logEvent(self._("kitops_event_add_kits_from_media") % self.koinst.kitmedia,
                      toStdout=False)

        kits = self.mountAndParseKitMedia()

        kitError = False

        if getattr(kits, 'ostype', None) is not None:
            self.runAddOSKit(kits)
        elif kits:
            # we cannot identify the distro -- treat as ordinary kit
            kits = self.selectKits(kits)

            for kit in kits:
                try:
                    api = kit[4]
                    new_kid, updated_ngs = self.koinst.addKit(kit, api)
                    kl.debug('SUCCESS performing add operation: %s(%s)',
                             kit[0], kit[1]['name'])
                    kit_str = "%s-%s-%s" % (kit[1]['name'],
                                            kit[1]['version'],
                                            kit[1]['arch'])
                    msg = self._("kitops_event_added_kit") % kit_str
                    self.logEvent(msg)
                    if updated_ngs:
                        msg = self._('New Node Groups associated: %s') % ', '.join(updated_ngs)
                        self.logEvent(msg)

                except (KitAlreadyInstalledError, InstallKitRPMError,
                        ComponentAlreadyInstalledError, AssertionError), e:
                    msg = '%s(%s): %s' % (kit[0], kit[1]['name'], e.args[0])
                    kl.debug('FAIL performing add operation: %s', msg)
                    self.logErrorEvent(msg)
                    kitError = True
            self.koinst.unmountMedia()
        else:
            msg = 'No kits found. Nothing to do.'
            kl.debug(msg)
            self.logErrorEvent(msg)
            sys.exit(EKITLOC_FAIL)

        if kitError:
            sys.exit(EKITLOC_FAIL)

        self.logEvent(self._("kitops_event_finish_add_kits_from_media") % self.koinst.kitmedia,
                      toStdout=False)
        kl.debug('SUCCESS performing add operation')

    def runAddOSKit(self, osdistro):
        try:
            kit = self.koinst.prepareOSKit(osdistro)
        except KitAlreadyInstalledError, e:
            kl.debug('FAIL performing add operation')
            self.logErrorEvent(e.args[0])
            sys.exit(EKITLOC_FAIL)
        except UnrecognizedKitMediaError, e:
            kl.debug('FAIL performing add operation: %s', e.args[0])
            self.logErrorEvent('Error: %s' % e.args[0])
            sys.exit(EKITADD_FAIL)

        res = ''
        while 1:    #loop to go through all the media disks...
            prepare_success = True
            if res:
                self.koinst.setKitMedia(res)
                kl.debug('Provided additional kit media: %s', res)

                try:
                    self.koinst.addKitPrepare()
                except UnrecognizedKitMediaError, e:
                    kl.debug('FAIL adding kit media%s: %s',
                             ' ' + res, e.args[0])
                    prepare_success = False

            if prepare_success:
                try:
                    self.koinst.copyOSKitMedia(kit)
                except CopyOSMediaError, e:
                    kl.debug('FAIL performing add operation')
                    self.logErrorEvent(e.args[0])
                    sys.exit(EKITLOC_FAIL)

                if self.suppress_questions:
                    # if questions are suppressed, assume only 1 cd
                    break
                else:
                    while not (res.lower() == 'y' or res.lower() == 'n'):
                        print 'Any more disks for this OS kit? [y/n] '
                        res = sys.stdin.readline().strip()
                        if res.lower() == 'n':
                            break

            # We need to clear the kit media now that we're done with it
            self.koinst.setKitMedia('')

            print "Please insert next disk if installing from phys. media NOW"
            if not prepare_success:
                print "Copying from the media you specified was not " + \
                      "successful. Try again..."
            print '(URI for next ISO | blank if phys. media | N to finish): '
            res = sys.stdin.readline().strip()
            if res == 'N': break
            elif not res: res = self.determineKitMedia()

        self.koinst.makeContribDir(kit)
        self.koinst.finalizeOSKit(kit)

        kit_str = "%s-%s-%s" % (kit['name'], kit['ver'], kit['arch'])
        msg = self._("kitops_event_added_kit") % kit_str
        self.logEvent(msg)

    def runListKit(self):
        kl.debug('Performing list operation')

        headers = ['Kit', 'Kid', 'Description', 'Version', 'Release', 'Architecture', 'OS Kit',
                   'Removable', 'Supported OS', 'Repositories', 'Node Groups']

        max_lengths = []
        for x in xrange(len(headers)):
            max_lengths.append(len(headers[x]))

        kits = self.koinst.listKit(self.kit_name, self.kit_id, self.kit_ver, self.kit_arch)

        for kit in kits:
            print "%s:\t\t%s" % (headers[0], kit.rname)
            print "%s:\t\t%s" % (headers[1], kit.kid)
            print "%s:\t%s" % (headers[2], kit.rdesc)
            print "%s:\t%s" % (headers[3], kit.version)

            if not kit.is_os() and self.koinst.getKitApi(kit.kid)!='0.1':
                print "%s:\t%s" % (headers[4], kit.release)

            sys.stdout.write("%s:\t" % headers[5])
            if kit.arch:
                sys.stdout.write(kit.arch)
            else:
                sys.stdout.write("noarch")

            sys.stdout.write("\n%s:\t\t" % headers[6])
            if kit.isOS:
                sys.stdout.write("Yes")
            else:
                sys.stdout.write("No")

            sys.stdout.write("\n%s:\t" % headers[7])
            if kit.removable:
                sys.stdout.write("Yes")
            else:
                sys.stdout.write("No")

            count=0
            if not kit.is_os():

                sys.stdout.write("\n%s:\t" % headers[8])
                osline=""
                os_set = kit.getSupportedDistro()
                if not os_set:
                    osline += "Unspecified"
                else:
                    for o in os_set:
                        osline += "%s" % o
                        if o:
                            osline += ", "

                        if (count % 2):
                            osline +="\n\t\t"
                        count += 1

                    if osline[-2:-1] == ',':
                        osline = osline[:-2]

                if osline[len(osline)-5:-4] == ',':
                    osline = osline[:len(osline)-5]

                sys.stdout.write(osline)

            ngnames = [ng.ngname for ng in
                       self.koinst.getNodeGroups(kit.kid)]

            sys.stdout.write("\n%s:\t" % headers[9])
            repoline=""
            for i,repo in enumerate(kit.repos):
                repoline += "%s" % repo.reponame
                repoline += ", "

                if (count % 2):
                    repoline += "\n\t\t"

            if repoline[-2:-1] == ',':
                repoline = repoline[:-2]
            if repoline[-5:-4] == ',':
                repoline = repoline[:len(repoline)-5]
            sys.stdout.write(repoline)

            sys.stdout.write("\n%s:\t" % headers[10])
            ngline=""
            count=0
            for ng in ngnames:
                ngline += "%s" % ng
                if ng:
                    ngline += ", "

                if (count % 2):
                    ngline +="\n\t\t"
                count += 1

            if ngline[-2:-1] == ',':
                ngline = ngline[:-2]

            if ngline[len(ngline)-5:-4] == ',':
                ngline = ngline[:len(ngline)-5]

            sys.stdout.write(ngline + '\n\n')

        kl.debug('SUCCESS performing list operation')

    def mountAndParseKitMedia(self):
        """Abort if mounting of kit media or parsing of kit metadata fails."""
        try:
            return self.koinst.addKitPrepare()
        except (CannotMountKitMediaError, UnrecognizedKitMediaError, AssertionError), e:
            kl.debug('FAIL performing add operation')
            self.logErrorEvent(e.args[0])
            sys.exit(EKITLOC_FAIL)
        except InvalidRPMHeader, e:
            invalid_rpm_name = path(e.args[0]).basename()
            kl.debug('FAIL performing add operation')
            self.logErrorEvent('Invalid RPM header: %s' % path(e.args[0]).basename())
            sys.exit(EKITLOC_FAIL)
        except KitinfoSyntaxError, e:
            kl.debug('FAIL performing add operation: %s', e.args[0])
            self.logErrorEvent('Error: %s' % e.args[0])
            sys.exit(EKIT_BAD)

    def determineKitMedia(self):
        media_choices = self.autoDetectMedia()
        #found_kits = sorted(media_choices.keys())

        if len(media_choices) == 1:
            return media_choices.keys()[0]
        else:
            return selectKitMedia(media_choices)

    def autoDetectMedia(self):
        """
        Attemp to find kit media.
        """

        import primitive.system.hardware.probe
        cdrom_dict = primitive.system.hardware.probe.getCDROM()
        cdrom_list = ['/dev/' + cd for cd in sorted(cdrom_dict.keys())]

        kl.debug('Media device list: %s', cdrom_list)

        available_kits = {}
        for cd in cdrom_list:
            try:
                self.koinst.mountMedia(cd)
                available_kits[cd] = self.koinst.getAvailableKits()
                self.koinst.unmountMedia()
            except CannotMountKitMediaError:
                pass

        if available_kits:
            return available_kits

        # at this point, we cannot find any kits
        kl.debug('Kit media neither specified nor found')
        self.logErrorEvent('Kit media neither specified nor found')
        sys.exit(EKITLOC_FAIL)

    def selectKitMedia(self, choices):
        """
        Present a list of kits for the user to select from.
        """

        choice_list = []
        while 1:
            for num_media in enumerate(sorted(choices)):
                choice_list.append(num_media[1])
                print '[%d] (%s) Kits:' % (num_media[0], num_media[1])

                for kit in choices[num_media[1]]:
                    print '     %s-%s-%s' % (kit[1]['name'], kit[1]['version'],
                                             kit[1]['arch'])

            print 'Select media to add from or ENTER to quit: '
            res = sys.stdin.readline().strip()
            if res == '':
                kl.debug('No media selected, terminating')
                self.koinst.unmountMedia()
                sys.exit(0)

            try:
                return choices[choice_list[int(res)]]
            except ValueError, IndexError:
                pass

    def selectKits(self, kits):
        """
        From a list of kits found inside a metakit, select kits to install.
        """

        if len(kits) == 1:
            return kits

        if self.kit_name is not None:
            for kit in kits:
                if self.kit_name == kit[1]['name']:
                    if self.kit_ver is not None \
                        and self.kit_ver != kit[1]['version']:
                        continue
                    if self.kit_arch is not None \
                        and self.kit_arch != kit[1]['arch']:
                        continue
                    kl.debug('Kit to install provided on command line: %s', kit)
                    return [kit]
            kl.debug('No kit found matching criteria: name: %s, version: %s, ' +
                     'arch: %s', self.kit_name, self.kit_ver, self.kit_arch)
            return []

        choice_list = []
        # silent mode, assume all kits are added
        if self.suppress_questions:
            return kits
        while 1:
            for num_kits in enumerate(kits):
                print '[%d]: %s-%s-%s' % (num_kits[0], num_kits[1][1]['name'],
                                          num_kits[1][1]['version'],
                                          num_kits[1][1]['arch'])

            print ('Provide a comma separated list of kits ' +
                   "to install,\n'all' to install all kits " +
                   'or ENTER to quit: ')
            res = sys.stdin.readline().strip()
            res = [x.strip() for x in res.split(',')]
            if res == ['']:
                kl.debug('No kits selected, terminating')
                self.koinst.unmountMedia()
                sys.exit(0)

            if res == ['all']:
                return kits

            try:
                selected_kits = []
                for x in res:
                    selected_kits.append(kits[int(x)])
                return selected_kits
            except ValueError, IndexError:
                pass

    def printHelp(self):
        self.parser.print_help()

def confirm(kits, msg, skip=True):
    headers = ['Kid', 'Kit', 'Version', 'Release', 'Architecture']
    max_lengths = []
    for x in xrange(len(headers)):
        max_lengths.append(len(headers[x]))

    kitlines = []
    for kit in kits:
        kitline = []
        kitline.append(str(kit.kid))
        kitline.append(kit.rname)
        kitline.append(kit.version)
        kitline.append(str(kit.release))
        kitline.append(kit.arch or 'noarch')

        for x in xrange(len(kitline)):
            linelengths = [len(l) for l in kitline[x].split('\n')]
            if max(linelengths) > max_lengths[x]:
                max_lengths[x] = max(linelengths)

        kitlines.append(kitline)

    printTable(headers, kitlines, max_lengths)

    print msg
    if not skip:
        print 'Confirm [y/N]: '
        res = sys.stdin.readline().strip()
    else:
        print 'Confirm [y/N]: y'
        res = 'y'

    if res.lower() == 'y' or res.lower == 'yes':
        return True

    return False

def printTable(titles, entries, widths):
    horline = '+'
    for width in widths:
        horline += '-' * (width + 2) + '+'

    print horline

    line = '|'
    for x in xrange(len(titles)):
        line += ' ' + titles[x].ljust(widths[x]) + ' |'

    print line
    print horline

    for entry in entries:
        newlines = True
        while newlines:
            newlines = False

            line = '|'
            for x in xrange(len(entry)):
                newline = entry[x].find('\n')
                if newline == -1:
                    thisentry = entry[x]
                    nextentry = ''
                else:
                    newlines = True
                    thisentry = entry[x][:newline]
                    nextentry = entry[x][newline + 1:]

                line += ' ' + thisentry.ljust(widths[x]) + ' |'
                entry[x] = nextentry

            print line

    print horline

if __name__ == '__main__':
    koinst = KitOps()
    app = KitOpsApp(koinst)
    app.run()
